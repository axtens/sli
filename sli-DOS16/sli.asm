; Generated by MoonRock 0.50 from sourcecode file SLI.SRC
; Compile time was 22:35:50 on 25-Jul-2006

; * Conditional directives: __EXE __8086
; * Compiled for maximum speed.
; * Lowest target processor: 8086
_text segment para public 'code'
assume cs:_text
_text ends
_strconst segment para public 'data'
assume cs:_strconst
_strconst ends
_data segment para public 'data'
assume cs:_data
_data ends
_text segment para public 'code'
assume cs:_text
$strsegsize equ 0FFFEh
public
start_of_code:
	push	es
	mov	bx,sp
	add	bx,17
	mov	cl,4
	shr	bx,cl
	mov	ax,ss
	add	bx,ax
	mov	ax,es
	sub	bx,ax
	mov	ah,4ah
	int	21h
	jc	_InitErr
	mov	ah,48h
	mov	bx,(($strsegsize / 16)+1)
	int	21h
	jc	_InitErr
	mov	ds,ax
	mov	es,ax
	mov	word ptr ss:[mr@ds],ax
	xor	di,di
	mov	cx,$strsegsize/2
	xor	ax,ax
	cld
	rep	stosw
	pop	word ptr ds:[mr@psp]
	jmp	mr@startup
_InitErr:
	mov	ah,9
	mov	dx,offset mr@InitMsg
	push	cs
	pop	ds
	int	21h
	jmp	_exit2
mr@InitMsg: db 'Memory allocation error$'

public __MAIN

__Main:
_text ends
_data segment para public 'data'
assume cs:_data
; ------------------------------------------------------------
t1	equ 00002h
t2	equ 00004h
mr@psp equ 00006h
bu_FFBLK	equ 08h
b_FFBLK_ATTR	equ 08h
w_FFBLK_TIME	equ 09h
w_FFBLK_DATE	equ 0Bh
d_FFBLK_SIZE	equ 0Dh
s_FFBLK_NAME	equ 011h
even
as_ARG_V equ 01Eh
s_CMD	equ 0E8h
w_ARG_C	equ 0EAh
s__ADDEXT	equ 0ECh
s__ADDNOEXT	equ 0EEh
s_SWAPPED	equ 0F0h
bu_TIMEBLK	equ 0F2h
b_TIMEBLK_HOUR	equ 0F2h
b_TIMEBLK_MINUTE	equ 0F3h
b_TIMEBLK_SECOND	equ 0F4h
b_TIMEBLK_SEC100	equ 0F5h
even
bu_DATEBLK	equ 0F6h
b_DATEBLK_DAY	equ 0F6h
b_DATEBLK_MONTH	equ 0F7h
w_DATEBLK_YEAR	equ 0F8h
b_DATEBLK_DOW	equ 0FAh
even
w_YESNO_	equ 0FBh
s_DEEPESTTOKEN	equ 0FDh
as_VARLIST equ 0FFh
w_CASESENS	equ 08D1h
w_ERRORFLAG	equ 08D3h
w_DEBUGGING	equ 08D5h
w_VARCOUNT	equ 08D7h
w_PROGMAX	equ 08D9h
w_TRANSLATION	equ 08DBh
s_VARVALUE	equ 08DDh
w_VAROFFSET	equ 08DFh
s_SUBST	equ 08E1h
s_CHOP_FIRST	equ 08E3h
s_CHOP_SECOND	equ 08E5h
s_COMSPEC	equ 08E7h
s_VARIABLE	equ 08E9h
s_VALUE	equ 08EBh
w_PROGLINE	equ 08EDh
w_PROGINCR	equ 08EFh
w_LABELOFFSET	equ 08F1h
s_CRLF	equ 08F3h
w_YES	equ 08F5h
w_NO	equ 08F7h
w_FILEHANDLE	equ 08F9h
w_FAILURE	equ 08FBh
s_TEMPONE	equ 08FDh
s_TEMPTWO	equ 08FFh
w_MESSAGES	equ 0901h
s_MR@NULL	equ 0903h
s_0@INPUTFILE	equ 0905h
w_0@J	equ 0907h
w_0@I	equ 0909h
s_0@C	equ 090Bh
w_0@T1	equ 090Dh
w_0@H	equ 090Fh
w_0@FOREVER	equ 0911h
s_0@INREC	equ 0913h
s_0@LINE	equ 0915h
s_1@LINE	equ 0917h
s_1@C1	equ 0919h
s_1@C2	equ 091Bh
s_2@THELINE	equ 091Dh
s_2@SUBSTTEMP	equ 091Fh
w_2@FOREVER	equ 0921h
s_3@DQUOTE	equ 0923h
s_3@SQUOTE	equ 0925h
s_3@ME	equ 0927h
w_3@FOREVER	equ 0929h
s_3@FIRST	equ 092Bh
s_4@QUOTER	equ 092Dh
s_4@ITEM	equ 092Fh
w_4@THERE	equ 0931h
w_5@SEP	equ 0933h
w_5@THERE	equ 0935h
s_5@ITEM	equ 0937h
w_6@THERE	equ 0939h
s_6@ITEM	equ 093Bh
s_7@ITEM	equ 093Dh
s_8@EXT	equ 093Fh
s_8@NAME	equ 0941h
s_8@TRUENAME	equ 0943h
w_8@EXTDOT	equ 0945h
s_9@REPLACEMENT	equ 0947h
s_9@SYMBOL	equ 0949h
s_9@TEMPLATE	equ 094Bh
w_9@FOREVER	equ 094Dh
w_9@SWAPFIND	equ 094Fh
w_9@LEFTSWAP	equ 0951h
s_9@SWAPLEFT	equ 0953h
w_9@RIGHTSWAP	equ 0955h
s_9@SWAPRIGHT	equ 0957h
s_10@CITEM	equ 0959h
w_10@S	equ 095Bh
s_11@VARVAL	equ 095Dh
s_11@VARNAME	equ 095Fh
s_11@VITEM	equ 0961h
s_12@VARNAME	equ 0963h
s_12@VLINE	equ 0965h
s_12@CERR	equ 0967h
w_13@OFFSET	equ 0969h
s_13@CTEMP	equ 096Bh
s_14@VNAME	equ 096Dh
s_14@GV_NAME	equ 096Fh
w_14@I	equ 0971h
s_14@GV_VALUE	equ 0973h
s_14@GV_TEST	equ 0975h
s_15@LNAME	equ 0977h
w_15@FOUND	equ 0979h
w_15@LABELLINE	equ 097Bh
s_15@LINE	equ 097Dh
s_15@INREC	equ 097Fh
s_15@CERRMSG	equ 0981h
w_16@FLAG	equ 0983h
w_16@STOP	equ 0985h
s_16@STOPPER	equ 0987h
w_17@FLAG	equ 0989h
s_18@ENDMARKER	equ 098Bh
s_18@STARTMARKER	equ 098Dh
s_18@LINE	equ 098Fh
w_18@DEPTH	equ 0991h
w_18@HERE	equ 0993h
w_18@ITEMSTART	equ 0995h
w_18@ITEMEND	equ 0997h
w_18@MAX	equ 0999h
w_18@MAXDEPTH	equ 099Bh
w_18@FOREVER	equ 099Dh
s_18@C	equ 099Fh
w_18@ITEMLEN	equ 09A1h
s_19@TWOTHING	equ 09A3h
s_19@ONETHING	equ 09A5h
s_20@REST	equ 09A7h
s_20@KWD	equ 09A9h
w_20@H	equ 09ABh
w_20@I	equ 09ADh
s_20@CERR	equ 09AFh
w_20@NTIMES	equ 09B1h
w_20@NRES	equ 09B3h
s_20@CRES	equ 09B5h
s_20@TEMP	equ 09B7h
w_20@EXIST	equ 09B9h
s_20@CERRMSG	equ 09BBh
w_20@T1	equ 09BDh
s_20@COMPAR	equ 09BFh
s_20@LH	equ 09C1h
w_20@_LH	equ 09C3h
s_20@RH	equ 09C5h
w_20@_RH	equ 09C7h
w_20@TESTRES	equ 09C9h
w_20@AMOUNT	equ 09CBh
w_20@CURRENT	equ 09CDh
w_20@FLAG	equ 09CFh
; ------------------------------------------------------------
_data ends
_text segment para public 'code'
assume cs:_text
_text ends
_text segment para public 'code'
assume cs:_text
_text ends
_data segment para public 'data'
assume cs:_data

; 0006	#include ffblk.h

; 0007	#include args.h

; 0008	#include addext.h

; 0009	#include swapper.h

; 0010	#include datetime.h

; 0011	#include yesno.h

; 0012	#include getdeept.h
_data ends
_text segment para public 'code'
assume cs:_text

; 0067	messages% = true
	mov	word ptr ds:[w_MESSAGES],-1

; 0069	tempone$ = chr( 254 )
	mov	bx,word ptr ds:[s_TEMPONE]
	call	_mem_free
	mov	bx,3
	call	_mem_alloc
	mov	word ptr ds:[di], 1
	mov	byte ptr ds:[di+2],254
	mov	word ptr ds:[s_TEMPONE],di

; 0070	temptwo$ = chr( 255 )
	mov	bx,word ptr ds:[s_TEMPTWO]
	call	_mem_free
	mov	bx,3
	call	_mem_alloc
	mov	word ptr ds:[di], 1
	mov	byte ptr ds:[di+2],255
	mov	word ptr ds:[s_TEMPTWO],di

; 0072	Yes% = false
	xor	ax,ax
	mov	word ptr ds:[w_YES],ax

; 0073	No% = false
	mov	word ptr ds:[w_NO],ax

; 0074	translation% = 1
	mov	word ptr ds:[w_TRANSLATION],1

; 0075	caseSens% = true
	mov	word ptr ds:[w_CASESENS],-1

; 0077	CRLF$ = chr( 13 ) + chr( 10 )
	mov	bx,word ptr ds:[s_CRLF]
	call	_mem_free
	mov	bx,3
	call	_mem_alloc
	mov	word ptr ds:[di], 1
	mov	byte ptr ds:[di+2],13
	call	_str_mark_di
	push	di
	mov	bx,3
	call	_mem_alloc
	mov	word ptr ds:[di], 1
	mov	byte ptr ds:[di+2],10
	call	_str_mark_di
	push	di
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s_CRLF],di
	call	_str_release

; 0078	debugging% = false
	xor	ax,ax
	mov	word ptr ds:[w_DEBUGGING],ax

; 0079	comspec$ = getenv( "COMSPEC" )
	mov	bx,word ptr ds:[s_COMSPEC]
	call	_mem_free
	mov	si,offset s_$SC_1
	call	_str_cs_ds
	push	si
	call	_getenviron
	pop	bx
	call	_mem_free
	mov	word ptr ds:[s_COMSPEC],di

; 0081	varcount% = 0
	xor	ax,ax
	mov	word ptr ds:[w_VARCOUNT],ax

; 0082	CALL DEFVAR( "$COMSPEC", comspec$ )
	mov	si,offset s_$SC_2
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_COMSPEC]
	call	__defvar
	call	_str_release

; 0083	call defvar( "$ERROR", "" )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	xor	ax,ax
	push	ax
	call	__defvar
	call	_str_release

; 0084	call defvar( "$EXEC", "" )
	mov	si,offset s_$SC_4
	call	_str_cs_ds_mark
	push	si
	xor	ax,ax
	push	ax
	call	__defvar
	call	_str_release

; 0085	call defvar( "$INPUT", "" )
	mov	si,offset s_$SC_5
	call	_str_cs_ds_mark
	push	si
	xor	ax,ax
	push	ax
	call	__defvar
	call	_str_release

; 0086	call defvar( "$OPEN", "" )
	mov	si,offset s_$SC_6
	call	_str_cs_ds_mark
	push	si
	xor	ax,ax
	push	ax
	call	__defvar
	call	_str_release

; 0087	call defvar( "$DONE", "FALSE" )
	mov	si,offset s_$SC_7
	call	_str_cs_ds_mark
	push	si
	mov	si,offset s_$SC_8
	call	_str_cs_ds_mark
	push	si
	call	__defvar
	call	_str_release

; 0088	call defvar( "$DATE", date )
	mov	si,offset s_$SC_9
	call	_str_cs_ds_mark
	push	si
	call	_get_date
	call	_str_mark_di
	push	di
	call	__defvar
	call	_str_release

; 0089	call defvar( "$NULL", "{}" )
	mov	si,offset s_$SC_10
	call	_str_cs_ds_mark
	push	si
	mov	si,offset s_$SC_11
	call	_str_cs_ds_mark
	push	si
	call	__defvar
	call	_str_release

; 0091	call getargs
	call	__getargs

; 0092	call defvar( "%0", arg_v$[ 0 ] )
	mov	si,offset s_$SC_12
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[as_ARG_V+00000h]
	call	__defvar
	call	_str_release

; 0093	if arg_c% < 2 then
	cmp	word ptr ds:[w_ARG_C],2
	jl	short LL1
	jmp	_nif1
LL1:

; 0094	print "no script file.\n"
	mov	di,offset s_$SC_13
	call	_echo_strconst

; 0095	end
	xor	al,al
	jmp	_exit

; 0096	endif
_nif1:

; 0098	inputfile$ = arg_v$[ 1 ]
	mov	bx,word ptr ds:[s_0@INPUTFILE]
	call	_mem_free
	mov	si,word ptr ds:[as_ARG_V+00002h]
	call	_str_copy
	mov	word ptr ds:[s_0@INPUTFILE],di

; 0099	call addext( inputfile$, ".SLI" )
	push	word ptr ds:[s_0@INPUTFILE]
	mov	si,offset s_$SC_14
	call	_str_cs_ds_mark
	push	si
	call	__addext
	call	_str_release

; 0100	inputfile$ = _addext$
	mov	bx,word ptr ds:[s_0@INPUTFILE]
	call	_mem_free
	mov	si,word ptr ds:[s__ADDEXT]
	call	_str_copy
	mov	word ptr ds:[s_0@INPUTFILE],di

; 0101	call defvar( "%1", inputfile$ )
	mov	si,offset s_$SC_15
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_0@INPUTFILE]
	call	__defvar
	call	_str_release

; 0103	if arg_c% > 2 then
	cmp	word ptr ds:[w_ARG_C],2
	jg	short LL2
	jmp	_nif2
LL2:

; 0104	j% = arg_c% - 1
	mov	ax,word ptr ds:[w_ARG_C]
	dec	ax
	mov	word ptr ds:[w_0@J],ax

; 0105	for i% = 2 to j%
	mov	word ptr ds:[w_0@I],2
_fornext1:

; 0106	c$ = str( i% )
	mov	bx,word ptr ds:[s_0@C]
	call	_mem_free
	mov	ax,word ptr ds:[w_0@I]
	call	_words
	mov	word ptr ds:[s_0@C],di

; 0107	c$ = ltrim( c$ )
	push	di
	mov	si,di
	call	_str_ltrim
	mov	word ptr ds:[s_0@C],di
	pop	bx
	call	_mem_free

; 0108	c$ = "%" + c$
	mov	si,offset s_$SC_16
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_0@C]
	mov	cx,2
	call	_str_mix
	mov	bx,word ptr ds:[s_0@C]
	call	_mem_free
	mov	word ptr ds:[s_0@C],di
	call	_str_release

; 0109	call defvar( c$, arg_v$[ i% ] )
	push	word ptr ds:[s_0@C]
	mov	bx,ds:[w_0@I]
	add	bx,bx
	push	word ptr ds:[bx+as_ARG_V]
	call	__defvar

; 0110	next i%
	mov	ax,word ptr ds:[w_0@I]
	inc	ax
	cmp	ax,ds:[w_0@J]
	jg	_fornext1end
	mov	word ptr ds:[w_0@I],ax
	jmp	_fornext1
_fornext1end:

; 0111	endif
_nif2:

; 0114	if fexist( inputfile$, 7 ) = false then
	mov	si,word ptr ds:[s_0@INPUTFILE]
	mov	cx,7
	call	_file_exist
	test	ax,ax
	jz	short LL3
	jmp	_nif3
LL3:

; 0115	print inputfile$ + " not found.\n\n"
	mov	di,word ptr ds:[s_0@INPUTFILE]
	call	_tty_str_dos
	mov	di,offset s_$SC_17
	call	_echo_strconst

; 0116	end
	xor	al,al
	jmp	_exit

; 0117	endif
_nif3:

; 0119	progMax%=0
	xor	ax,ax
	mov	word ptr ds:[w_PROGMAX],ax

; 0120	h% = fopen( inputfile$, readonly )
	mov	si,word ptr ds:[s_0@INPUTFILE]
	xor	cx,cx
	call	_file_open
	mov	word ptr ds:[w_0@H],ax

; 0121	forever% = true
	mov	word ptr ds:[w_0@FOREVER],-1

; 0122	while forever%
_whl1:
	cmp	word ptr ds:[w_0@FOREVER],-1
	jz	short LL4
	jmp	_wnd1
LL4:

; 0123	finput( h%, inrec$ )
	mov	bx,word ptr ds:[s_0@INREC]
	call	_mem_free
	mov	bx,word ptr ds:[w_0@H]
	call	_finput
	mov	word ptr ds:[s_0@INREC],di

; 0124	if feof( h% ) = true then
	mov	bx,word ptr ds:[w_0@H]
	call	_file_eof
	cmp	ax,-1
	jz	short LL5
	jmp	_nif4
LL5:

; 0125	exit while
	jmp	_wnd1

; 0126	endif
_nif4:

; 0127	inrec$ = ltrim( inrec$ )
	push	word ptr ds:[s_0@INREC]
	mov	si,word ptr ds:[s_0@INREC]
	call	_str_ltrim
	mov	word ptr ds:[s_0@INREC],di
	pop	bx
	call	_mem_free

; 0128	if len( inrec$ ) > 0 then
	mov	bx,word ptr ds:[s_0@INREC]
	mov	ax,ds:[bx]
	test	ax,ax
	jg	short LL6
	jmp	_nif5
LL6:

; 0129	call chop( inrec$ )
	push	word ptr ds:[s_0@INREC]
	call	__chop

; 0130	chop_first$ = ucase( chop_first$ )
	push	word ptr ds:[s_CHOP_FIRST]
	mov	si,word ptr ds:[s_CHOP_FIRST]
	call	_str_ucase
	mov	word ptr ds:[s_CHOP_FIRST],di
	pop	bx
	call	_mem_free

; 0131	if chop_first$ = "DEFINE" then
	mov	si,offset s_$SC_18
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL7
	jmp	_nif6
LL7:

; 0132	call chop( chop_second$ )
	push	word ptr ds:[s_CHOP_SECOND]
	call	__chop

; 0133	call defvar( chop_first$, chop_second$ )
	push	word ptr ds:[s_CHOP_FIRST]
	push	word ptr ds:[s_CHOP_SECOND]
	call	__defvar

; 0134	else
	jmp	_eif6
_nif6:

; 0135	progMax% = progMax% + 1
	inc	word ptr ds:[w_PROGMAX]

; 0136	line$ = str( progMax% )
	mov	bx,word ptr ds:[s_0@LINE]
	call	_mem_free
	mov	ax,word ptr ds:[w_PROGMAX]
	call	_words
	mov	word ptr ds:[s_0@LINE],di

; 0137	line$ = ltrim( line$ )
	push	di
	mov	si,di
	call	_str_ltrim
	mov	word ptr ds:[s_0@LINE],di
	pop	bx
	call	_mem_free

; 0138	line$ = "$LINE" + line$
	mov	si,offset s_$SC_19
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_0@LINE]
	mov	cx,2
	call	_str_mix
	mov	bx,word ptr ds:[s_0@LINE]
	call	_mem_free
	mov	word ptr ds:[s_0@LINE],di
	call	_str_release

; 0139	call defvar( line$, inrec$ )
	push	word ptr ds:[s_0@LINE]
	push	word ptr ds:[s_0@INREC]
	call	__defvar

; 0140	endif
_eif6:

; 0141	endif
_nif5:

; 0142	wend
	jmp	_whl1
_wnd1:

; 0143	fclose( h% )
	mov	bx,word ptr ds:[w_0@H]
	call	_file_close

; 0144	if progMax%=0 then
	cmp	word ptr ds:[w_PROGMAX],0
	jz	short LL8
	jmp	_nif7
LL8:

; 0145	print "No instructions in file " + inputfile$ + "\n"
	mov	di,offset s_$SC_20
	call	_echo_strconst
	mov	di,word ptr ds:[s_0@INPUTFILE]
	call	_tty_str_dos
	mov	di,offset s_$SC_21
	call	_echo_strconst

; 0146	end
	xor	al,al
	jmp	_exit

; 0147	endif
_nif7:

; 0149	forever% = true
	mov	word ptr ds:[w_0@FOREVER],-1

; 0150	progLine% = 1
	mov	word ptr ds:[w_PROGLINE],1

; 0151	while forever%
_whl2:
	cmp	word ptr ds:[w_0@FOREVER],-1
	jz	short LL9
	jmp	_wnd2
LL9:

; 0152	call defvar( "$TIME", time )
	mov	si,offset s_$SC_22
	call	_str_cs_ds_mark
	push	si
	call	_get_time
	call	_str_mark_di
	push	di
	call	__defvar
	call	_str_release

; 0153	line$ = str( progLine% )
	mov	bx,word ptr ds:[s_0@LINE]
	call	_mem_free
	mov	ax,word ptr ds:[w_PROGLINE]
	call	_words
	mov	word ptr ds:[s_0@LINE],di

; 0154	line$ = ltrim( line$ )
	push	di
	mov	si,di
	call	_str_ltrim
	mov	word ptr ds:[s_0@LINE],di
	pop	bx
	call	_mem_free

; 0155	line$ = "$LINE" + line$
	mov	si,offset s_$SC_19
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_0@LINE]
	mov	cx,2
	call	_str_mix
	mov	bx,word ptr ds:[s_0@LINE]
	call	_mem_free
	mov	word ptr ds:[s_0@LINE],di
	call	_str_release

; 0156	call getvar( line$ )
	push	word ptr ds:[s_0@LINE]
	call	__getvar

; 0157	inrec$ = varvalue$
	mov	bx,word ptr ds:[s_0@INREC]
	call	_mem_free
	mov	si,word ptr ds:[s_VARVALUE]
	call	_str_copy
	mov	word ptr ds:[s_0@INREC],di

; 0158	errorflag% = false
	xor	ax,ax
	mov	word ptr ds:[w_ERRORFLAG],ax

; 0160	progIncr% = 1
	mov	word ptr ds:[w_PROGINCR],1

; 0161	call parse( inrec$ )
	push	word ptr ds:[s_0@INREC]
	call	__parse

; 0162	if errorflag% = true then
	cmp	word ptr ds:[w_ERRORFLAG],-1
	jz	short LL10
	jmp	_nif8
LL10:

; 0163	if messages% = true then
	cmp	word ptr ds:[w_MESSAGES],-1
	jz	short LL11
	jmp	_nif9
LL11:

; 0164	call getvar( "$ERROR" )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	call	__getvar
	call	_str_release

; 0165	print "Error in line " + progLine% + "--> " + inrec$ + ":\n\t" + varva
;        lue$ + "\n"'
	mov	di,offset s_$SC_23
	call	_echo_strconst
	mov	ax,word ptr ds:[w_PROGLINE]
	call	_echo_words
	mov	di,offset s_$SC_24
	call	_echo_strconst
	mov	di,word ptr ds:[s_0@INREC]
	call	_tty_str_dos
	mov	di,offset s_$SC_25
	call	_echo_strconst
	mov	di,word ptr ds:[s_VARVALUE]
	call	_tty_str_dos
	mov	di,offset s_$SC_21
	call	_echo_strconst

; 0166	call defvar( "$ERROR", "" )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	xor	ax,ax
	push	ax
	call	__defvar
	call	_str_release

; 0167	endif
_nif9:

; 0168	errorflag% = false
	xor	ax,ax
	mov	word ptr ds:[w_ERRORFLAG],ax

; 0169	endif
_nif8:

; 0170	call getvar( "$DONE" )
	mov	si,offset s_$SC_7
	call	_str_cs_ds_mark
	push	si
	call	__getvar
	call	_str_release

; 0171	if varvalue$ = "TRUE" then
	mov	si,offset s_$SC_26
	call	_str_cs_ds
	push	si
	mov	di,word ptr ds:[s_VARVALUE]
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL12
	jmp	_nif10
LL12:

; 0172	exit while
	jmp	_wnd2

; 0173	endif
_nif10:

; 0174	progLine% = progLine% + progIncr%
	mov	ax,word ptr ds:[w_PROGINCR]
	add	ds:[w_PROGLINE],ax

; 0175	if progLine% > progMax% then
	mov	ax,word ptr ds:[w_PROGLINE]
	cmp	ax,ds:[w_PROGMAX]
	jg	short LL13
	jmp	_nif11
LL13:

; 0176	exit while
	jmp	_wnd2

; 0177	endif
_nif11:

; 0178	wend
	jmp	_whl2
_wnd2:

; 0179	end
	xor	al,al
	jmp	_exit

; 0181	sub parse( line$ )
public __PARSE
__parse proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_1@LINE],di

; 0182	call chop( line$ )
	push	word ptr ds:[s_1@LINE]
	call	__chop

; 0183	c1$ = chop_first$
	mov	bx,word ptr ds:[s_1@C1]
	call	_mem_free
	mov	si,word ptr ds:[s_CHOP_FIRST]
	call	_str_copy
	mov	word ptr ds:[s_1@C1],di

; 0184	c2$ = chop_second$
	mov	bx,word ptr ds:[s_1@C2]
	call	_mem_free
	mov	si,word ptr ds:[s_CHOP_SECOND]
	call	_str_copy
	mov	word ptr ds:[s_1@C2],di

; 0185	call process( c1$, c2$ )
	push	word ptr ds:[s_1@C1]
	push	word ptr ds:[s_1@C2]
	call	__process

; 0186	end sub
__parse_end:
	mov	si,offset mr@cleanup_parse
	call	_sub_cleanup
	ret	2
	mr@cleanup_parse: dw s_1@LINE,s_1@C1,s_1@C2,0
__parse endp

; 0188	sub Substitute( theline$ ) ' returning Subst$
public __SUBSTITUTE
__substitute proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_2@THELINE],di

; 0189	call debug( "Substitue: theline$=" , theline$ )
	mov	si,offset s_$SC_27
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_2@THELINE]
	call	__debug
	call	_str_release

; 0190	SubstTemp$ = theline$
	mov	bx,word ptr ds:[s_2@SUBSTTEMP]
	call	_mem_free
	mov	si,word ptr ds:[s_2@THELINE]
	call	_str_copy
	mov	word ptr ds:[s_2@SUBSTTEMP],di

; 0191	call swapper( SubstTemp$, "{{}", tempone$ )
	push	word ptr ds:[s_2@SUBSTTEMP]
	mov	si,offset s_$SC_28
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_TEMPONE]
	call	__swapper
	call	_str_release

; 0192	SubstTemp$ = swapped$
	mov	bx,word ptr ds:[s_2@SUBSTTEMP]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	call	_str_copy
	mov	word ptr ds:[s_2@SUBSTTEMP],di

; 0193	call swapper( SubstTemp$, "{}}", temptwo$ )
	push	word ptr ds:[s_2@SUBSTTEMP]
	mov	si,offset s_$SC_29
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_TEMPTWO]
	call	__swapper
	call	_str_release

; 0194	SubstTemp$ = swapped$
	mov	bx,word ptr ds:[s_2@SUBSTTEMP]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	call	_str_copy
	mov	word ptr ds:[s_2@SUBSTTEMP],di

; 0195	forever% = true
	mov	word ptr ds:[w_2@FOREVER],-1

; 0196	while forever%
_whl3:
	cmp	word ptr ds:[w_2@FOREVER],-1
	jz	short LL14
	jmp	_wnd3
LL14:

; 0197	call getdeepesttoken( SubstTemp$, "{", "}" )
	push	word ptr ds:[s_2@SUBSTTEMP]
	mov	si,offset s_$SC_30
	call	_str_cs_ds_mark
	push	si
	mov	si,offset s_$SC_31
	call	_str_cs_ds_mark
	push	si
	call	__getdeepesttoken
	call	_str_release

; 0198	call debug( "deepestToken$=", deepestToken$ )
	mov	si,offset s_$SC_32
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_DEEPESTTOKEN]
	call	__debug
	call	_str_release

; 0199	if deepestToken$ = "" then
	mov	si,word ptr ds:[s_DEEPESTTOKEN]
	mov	cx,ds:[si]
	jcxz	short LL15
	jmp	_nif12
LL15:

; 0200	call swapper( SubstTemp$, "{}", "" )
	push	word ptr ds:[s_2@SUBSTTEMP]
	mov	si,offset s_$SC_11
	call	_str_cs_ds_mark
	push	si
	xor	ax,ax
	push	ax
	call	__swapper
	call	_str_release

; 0201	call debug("swapped$=", swapped$ )
	mov	si,offset s_$SC_33
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SWAPPED]
	call	__debug
	call	_str_release

; 0202	SubstTemp$ = swapped$
	mov	bx,word ptr ds:[s_2@SUBSTTEMP]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	call	_str_copy
	mov	word ptr ds:[s_2@SUBSTTEMP],di

; 0203	exit while
	jmp	_wnd3

; 0204	endif
_nif12:

; 0205	call getvar( deepestToken$ )
	push	word ptr ds:[s_DEEPESTTOKEN]
	call	__getvar

; 0206	call debug("varvalue$=", varvalue$ )
	mov	si,offset s_$SC_34
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_VARVALUE]
	call	__debug
	call	_str_release

; 0207	deepestToken$ = "{" + deepestToken$ + "}"
	mov	si,offset s_$SC_30
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_DEEPESTTOKEN]
	mov	si,offset s_$SC_31
	call	_str_cs_ds_mark
	push	si
	mov	cx,3
	call	_str_mix
	mov	bx,word ptr ds:[s_DEEPESTTOKEN]
	call	_mem_free
	mov	word ptr ds:[s_DEEPESTTOKEN],di
	call	_str_release

; 0208	call swapper( SubstTemp$, deepestToken$, varvalue$ )
	push	word ptr ds:[s_2@SUBSTTEMP]
	push	word ptr ds:[s_DEEPESTTOKEN]
	push	word ptr ds:[s_VARVALUE]
	call	__swapper

; 0209	call debug("swapped$=", swapped$ )
	mov	si,offset s_$SC_33
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SWAPPED]
	call	__debug
	call	_str_release

; 0210	SubstTemp$ = swapped$
	mov	bx,word ptr ds:[s_2@SUBSTTEMP]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	call	_str_copy
	mov	word ptr ds:[s_2@SUBSTTEMP],di

; 0211	wend
	jmp	_whl3
_wnd3:

; 0212	call swapper( SubstTemp$, tempone$, "{" )
	push	word ptr ds:[s_2@SUBSTTEMP]
	push	word ptr ds:[s_TEMPONE]
	mov	si,offset s_$SC_30
	call	_str_cs_ds_mark
	push	si
	call	__swapper
	call	_str_release

; 0213	SubstTemp$ = swapped$
	mov	bx,word ptr ds:[s_2@SUBSTTEMP]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	call	_str_copy
	mov	word ptr ds:[s_2@SUBSTTEMP],di

; 0214	call swapper( SubstTemp$, temptwo$, "{" )
	push	word ptr ds:[s_2@SUBSTTEMP]
	push	word ptr ds:[s_TEMPTWO]
	mov	si,offset s_$SC_30
	call	_str_cs_ds_mark
	push	si
	call	__swapper
	call	_str_release

; 0215	SubstTemp$ = swapped$
	mov	bx,word ptr ds:[s_2@SUBSTTEMP]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	call	_str_copy
	mov	word ptr ds:[s_2@SUBSTTEMP],di

; 0216	subst$ = substtemp$
	mov	bx,word ptr ds:[s_SUBST]
	call	_mem_free
	mov	si,word ptr ds:[s_2@SUBSTTEMP]
	call	_str_copy
	mov	word ptr ds:[s_SUBST],di

; 0231	end sub
__substitute_end:
	mov	si,offset mr@cleanup_substitute
	call	_sub_cleanup
	ret	2
	mr@cleanup_substitute: dw s_2@THELINE,s_2@SUBSTTEMP,0
__substitute endp

; 0233	#include args.sub

; 0001	sub getargs
public __GETARGS
__getargs proc near

; 0002	dquote$ = chr(34)
	mov	bx,word ptr ds:[s_3@DQUOTE]
	call	_mem_free
	mov	bx,3
	call	_mem_alloc
	mov	word ptr ds:[di], 1
	mov	byte ptr ds:[di+2],34
	mov	word ptr ds:[s_3@DQUOTE],di

; 0003	squote$ = "'"
	mov	bx,word ptr ds:[s_3@SQUOTE]
	call	_mem_free
	mov	si,offset s_$SC_35
	call	_str_cs_ds
	mov	word ptr ds:[s_3@SQUOTE],si

; 0005	me$ = mypath()
	mov	bx,word ptr ds:[s_3@ME]
	call	_mem_free
	call	_mypath
	mov	word ptr ds:[s_3@ME],di

; 0006	me$ = ftruename( me$ )
	push	di
	mov	si,word ptr ds:[s_3@ME]
	call	_file_truename
	mov	word ptr ds:[s_3@ME],di
	pop	bx
	call	_mem_free

; 0007	arg_v$[ 0 ] = me$
	mov	bx,word ptr ds:[as_ARG_V+00000h]
	call	_mem_free
	mov	si,di
	call	_str_copy
	mov	word ptr ds:[as_ARG_V+00000h],di

; 0009	arg_c% = 1
	mov	word ptr ds:[w_ARG_C],1

; 0012	cmd$ = cmdline
	mov	bx,word ptr ds:[s_CMD]
	call	_mem_free
	call	_cmdline
	mov	word ptr ds:[s_CMD],di

; 0015	forever% = true
	mov	word ptr ds:[w_3@FOREVER],-1

; 0016	while forever%
_whl4:
	cmp	word ptr ds:[w_3@FOREVER],-1
	jz	short LL16
	jmp	_wnd4
LL16:

; 0017	cmd$ = ltrim( cmd$ )
	push	word ptr ds:[s_CMD]
	mov	si,word ptr ds:[s_CMD]
	call	_str_ltrim
	mov	word ptr ds:[s_CMD],di
	pop	bx
	call	_mem_free

; 0018	if cmd$ = "" then
	mov	cx,ds:[di]
	jcxz	short LL17
	jmp	_nif13
LL17:

; 0019	exit while
	jmp	_wnd4

; 0020	endif
_nif13:

; 0023	first$ = left( cmd$, 1 )
	mov	bx,word ptr ds:[s_3@FIRST]
	call	_mem_free
	mov	si,word ptr ds:[s_CMD]
	mov	cx,1
	call	_str_left
	mov	word ptr ds:[s_3@FIRST],di

; 0025	select case first$
	

; 0026	case squote$
	mov	di,word ptr ds:[s_3@FIRST]
	mov	si,word ptr ds:[s_3@SQUOTE]
	call	_str_compare
	test	ax,ax
	jnz	_cont0_0
	jmp	_clst0_1
_cont0_0:

; 0027	call quoted( squote$ )
	push	word ptr ds:[s_3@SQUOTE]
	call	__quoted

; 0028	case dquote$
	jmp	_clst0_end
_clst0_1:
	mov	di,word ptr ds:[s_3@FIRST]
	mov	si,word ptr ds:[s_3@DQUOTE]
	call	_str_compare
	test	ax,ax
	jnz	_cont0_1
	jmp	_clst0_2
_cont0_1:

; 0029	call quoted( dquote$ )
	push	word ptr ds:[s_3@DQUOTE]
	call	__quoted

; 0030	case "/"
	jmp	_clst0_end
_clst0_2:
	mov	di,word ptr ds:[s_3@FIRST]
	mov	si,offset s_$SC_36
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont0_2
	jmp	_clst0_3
_cont0_2:

; 0031	call param
	call	__param

; 0032	case "-"
	jmp	_clst0_end
_clst0_3:
	mov	di,word ptr ds:[s_3@FIRST]
	mov	si,offset s_$SC_37
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont0_3
	jmp	_clst0_4
_cont0_3:

; 0033	call param
	call	__param

; 0034	case else
	jmp	_clst0_end
_clst0_4:

; 0035	call other
	call	__other

; 0036	end select
_clst0_end:

; 0037	wend
	jmp	_whl4
_wnd4:

; 0038	end sub
__getargs_end:
	mov	si,offset mr@cleanup_getargs
	call	_sub_cleanup
	ret
	mr@cleanup_getargs: dw s_3@DQUOTE,s_3@SQUOTE,s_3@ME,s_3@FIRST,0
__getargs endp

; 0039	sub quoted( quoter$ )
public __QUOTED
__quoted proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_4@QUOTER],di

; 0040	item$ = mid( cmd$, 2 )
	mov	bx,word ptr ds:[s_4@ITEM]
	call	_mem_free
	mov	si,word ptr ds:[s_CMD]
	mov	bx,2
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_4@ITEM],di

; 0041	there% = sinstr( item$, quoter$ )
	mov	si,di
	mov	di,word ptr ds:[s_4@QUOTER]
	call	_sinstr
	mov	word ptr ds:[w_4@THERE],ax

; 0042	if there% > 0 then
	test	ax,ax
	jg	short LL18
	jmp	_nif14
LL18:

; 0043	there% = there% - 1
	dec	word ptr ds:[w_4@THERE]

; 0044	item$ = left( item$, there% ) 'mid( item$, 1, there% )
	push	word ptr ds:[s_4@ITEM]
	mov	si,word ptr ds:[s_4@ITEM]
	mov	cx,ds:[w_4@THERE]
	call	_str_left
	mov	word ptr ds:[s_4@ITEM],di
	pop	bx
	call	_mem_free

; 0045	there% = there% + 3
	add	word ptr ds:[w_4@THERE],3

; 0047	cmd$ = mid( cmd$, there% )
	push	word ptr ds:[s_CMD]
	mov	si,word ptr ds:[s_CMD]
	mov	bx,word ptr ds:[w_4@THERE]
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_CMD],di
	pop	bx
	call	_mem_free

; 0048	else
	jmp	_eif14
_nif14:

; 0049	cmd$ = ""
	mov	bx,word ptr ds:[s_CMD]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_CMD],ax

; 0050	endif
_eif14:

; 0051	call store( item$ )
	push	word ptr ds:[s_4@ITEM]
	call	__store

; 0052	end sub
__quoted_end:
	mov	si,offset mr@cleanup_quoted
	call	_sub_cleanup
	ret	2
	mr@cleanup_quoted: dw s_4@QUOTER,s_4@ITEM,0
__quoted endp

; 0054	sub param
public __PARAM
__param proc near

; 0055	sep% = 32
	mov	word ptr ds:[w_5@SEP],32

; 0056	there% = cinstr( cmd$, sep% )
	mov	si,word ptr ds:[s_CMD]
	mov	cx,ds:[w_5@SEP]
	call	_cinstr
	mov	word ptr ds:[w_5@THERE],ax

; 0057	if there% > 0 then
	test	ax,ax
	jg	short LL19
	jmp	_nif15
LL19:

; 0058	there% = there% - 1
	dec	word ptr ds:[w_5@THERE]

; 0059	item$ = left( cmd$, there% )
	mov	bx,word ptr ds:[s_5@ITEM]
	call	_mem_free
	mov	si,word ptr ds:[s_CMD]
	mov	cx,ds:[w_5@THERE]
	call	_str_left
	mov	word ptr ds:[s_5@ITEM],di

; 0061	there% = there% + 2
	add	word ptr ds:[w_5@THERE],2

; 0062	cmd$ = mid( cmd$, there% )
	push	word ptr ds:[s_CMD]
	mov	si,word ptr ds:[s_CMD]
	mov	bx,word ptr ds:[w_5@THERE]
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_CMD],di
	pop	bx
	call	_mem_free

; 0063	else
	jmp	_eif15
_nif15:

; 0064	item$ = cmd$
	mov	bx,word ptr ds:[s_5@ITEM]
	call	_mem_free
	mov	si,word ptr ds:[s_CMD]
	call	_str_copy
	mov	word ptr ds:[s_5@ITEM],di

; 0065	cmd$ = ""
	mov	bx,word ptr ds:[s_CMD]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_CMD],ax

; 0066	endif
_eif15:

; 0067	call store( item$ )
	push	word ptr ds:[s_5@ITEM]
	call	__store

; 0068	end sub
__param_end:
	mov	si,offset mr@cleanup_param
	call	_sub_cleanup
	ret
	mr@cleanup_param: dw s_5@ITEM,0
__param endp

; 0070	sub other
public __OTHER
__other proc near

; 0072	there% = cinstr( cmd$, 32 )
	mov	si,word ptr ds:[s_CMD]
	mov	cx,32
	call	_cinstr
	mov	word ptr ds:[w_6@THERE],ax

; 0073	if there% > 0 then
	test	ax,ax
	jg	short LL20
	jmp	_nif16
LL20:

; 0074	there% = there% - 1
	dec	word ptr ds:[w_6@THERE]

; 0075	item$ = left( cmd$, there% )
	mov	bx,word ptr ds:[s_6@ITEM]
	call	_mem_free
	mov	si,word ptr ds:[s_CMD]
	mov	cx,ds:[w_6@THERE]
	call	_str_left
	mov	word ptr ds:[s_6@ITEM],di

; 0077	there% = there% + 2
	add	word ptr ds:[w_6@THERE],2

; 0078	cmd$ = mid( cmd$, there% )
	push	word ptr ds:[s_CMD]
	mov	si,word ptr ds:[s_CMD]
	mov	bx,word ptr ds:[w_6@THERE]
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_CMD],di
	pop	bx
	call	_mem_free

; 0079	else
	jmp	_eif16
_nif16:

; 0080	item$ = cmd$
	mov	bx,word ptr ds:[s_6@ITEM]
	call	_mem_free
	mov	si,word ptr ds:[s_CMD]
	call	_str_copy
	mov	word ptr ds:[s_6@ITEM],di

; 0081	cmd$ = ""
	mov	bx,word ptr ds:[s_CMD]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_CMD],ax

; 0082	endif
_eif16:

; 0083	call store( item$ )
	push	word ptr ds:[s_6@ITEM]
	call	__store

; 0084	end sub
__other_end:
	mov	si,offset mr@cleanup_other
	call	_sub_cleanup
	ret
	mr@cleanup_other: dw s_6@ITEM,0
__other endp

; 0086	sub store( item$ )
public __STORE
__store proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_7@ITEM],di

; 0087	arg_v$[ arg_c% ] = item$
	mov	bp,ds:[w_ARG_C]
	add	bp,bp
	mov	bx,word ptr ds:[bp+as_ARG_V]
	call	_mem_free
	mov	si,word ptr ds:[s_7@ITEM]
	call	_str_copy
	mov	word ptr ds:[bp+as_ARG_V],di

; 0088	arg_c% = arg_c% + 1
	inc	word ptr ds:[w_ARG_C]

; 0089	end sub
__store_end:
	mov	si,offset mr@cleanup_store
	call	_sub_cleanup
	ret	2
	mr@cleanup_store: dw s_7@ITEM,0
__store endp

; 0234	#include addext.sub

; 0001	sub addext( name$, ext$ )
public __ADDEXT
__addext proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_8@EXT],di
	mov	si,[bp+4]
	call	_str_copy
	mov	word ptr ds:[s_8@NAME],di

; 0002	truename$ = ftruename( name$ )
	mov	bx,word ptr ds:[s_8@TRUENAME]
	call	_mem_free
	mov	si,word ptr ds:[s_8@NAME]
	call	_file_truename
	mov	word ptr ds:[s_8@TRUENAME],di

; 0003	extdot% = cinstr( truename$, 46 )
	mov	si,di
	mov	cx,46
	call	_cinstr
	mov	word ptr ds:[w_8@EXTDOT],ax

; 0004	if extdot% > 0 then
	test	ax,ax
	jg	short LL21
	jmp	_nif17
LL21:

; 0005	extdot% = extdot% - 1
	dec	word ptr ds:[w_8@EXTDOT]

; 0006	_addnoext$ = left( truename$, extdot% )
	mov	bx,word ptr ds:[s__ADDNOEXT]
	call	_mem_free
	mov	si,word ptr ds:[s_8@TRUENAME]
	mov	cx,ds:[w_8@EXTDOT]
	call	_str_left
	mov	word ptr ds:[s__ADDNOEXT],di

; 0007	else
	jmp	_eif17
_nif17:

; 0008	_addnoext$ = truename$
	mov	bx,word ptr ds:[s__ADDNOEXT]
	call	_mem_free
	mov	si,word ptr ds:[s_8@TRUENAME]
	call	_str_copy
	mov	word ptr ds:[s__ADDNOEXT],di

; 0009	endif
_eif17:

; 0010	_addext$ = _addnoext$ + ext$
	mov	bx,word ptr ds:[s__ADDEXT]
	call	_mem_free
	push	word ptr ds:[s__ADDNOEXT]
	push	word ptr ds:[s_8@EXT]
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s__ADDEXT],di

; 0011	end sub
__addext_end:
	mov	si,offset mr@cleanup_addext
	call	_sub_cleanup
	ret	4
	mr@cleanup_addext: dw s_8@EXT,s_8@NAME,s_8@TRUENAME,0
__addext endp

; 0235	#include swapper.sub

; 0001	sub swapper( template$, symbol$, replacement$ )
public __SWAPPER
__swapper proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_9@REPLACEMENT],di
	mov	si,[bp+4]
	call	_str_copy
	mov	word ptr ds:[s_9@SYMBOL],di
	mov	si,[bp+6]
	call	_str_copy
	mov	word ptr ds:[s_9@TEMPLATE],di

; 0002	forever% = true
	mov	word ptr ds:[w_9@FOREVER],-1

; 0003	swapped$ = template$
	mov	bx,word ptr ds:[s_SWAPPED]
	call	_mem_free
	mov	si,word ptr ds:[s_9@TEMPLATE]
	call	_str_copy
	mov	word ptr ds:[s_SWAPPED],di

; 0004	if len( symbol$ ) < 1
	mov	bx,word ptr ds:[s_9@SYMBOL]
	mov	ax,ds:[bx]
	cmp	ax,1
	jl	short LL22
	jmp	_nif18
LL22:

; 0005	exit sub
	jmp	__swapper_end

; 0006	endif
_nif18:

; 0007	while forever%
_whl5:
	cmp	word ptr ds:[w_9@FOREVER],-1
	jz	short LL23
	jmp	_wnd5
LL23:

; 0008	swapfind% = instr( swapped$, symbol$ )
	mov	di,word ptr ds:[s_SWAPPED]
	mov	si,word ptr ds:[s_9@SYMBOL]
	call	_str_instr
	mov	word ptr ds:[w_9@SWAPFIND],ax

; 0009	if swapfind% > 0 then
	test	ax,ax
	jg	short LL24
	jmp	_nif19
LL24:

; 0010	leftswap% = swapfind% - 1
	mov	ax,word ptr ds:[w_9@SWAPFIND]
	dec	ax
	mov	word ptr ds:[w_9@LEFTSWAP],ax

; 0011	swapleft$ = left( swapped$, leftswap% )
	mov	bx,word ptr ds:[s_9@SWAPLEFT]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	mov	cx,ds:[w_9@LEFTSWAP]
	call	_str_left
	mov	word ptr ds:[s_9@SWAPLEFT],di

; 0012	rightswap% = swapfind% + len( symbol$ )
	mov	ax,word ptr ds:[w_9@SWAPFIND]
	mov	bx,word ptr ds:[s_9@SYMBOL]
	mov	bx,ds:[bx]
	add	ax,bx
	mov	word ptr ds:[w_9@RIGHTSWAP],ax

; 0013	swapright$ = mid( swapped$, rightswap% )
	mov	bx,word ptr ds:[s_9@SWAPRIGHT]
	call	_mem_free
	mov	si,word ptr ds:[s_SWAPPED]
	mov	bx,word ptr ds:[w_9@RIGHTSWAP]
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_9@SWAPRIGHT],di

; 0014	swapped$ = swapleft$ + replacement$ + swapright$
	mov	bx,word ptr ds:[s_SWAPPED]
	call	_mem_free
	push	word ptr ds:[s_9@SWAPLEFT]
	push	word ptr ds:[s_9@REPLACEMENT]
	push	word ptr ds:[s_9@SWAPRIGHT]
	mov	cx,3
	call	_str_mix
	mov	word ptr ds:[s_SWAPPED],di

; 0015	else
	jmp	_eif19
_nif19:

; 0016	exit while
	jmp	_wnd5

; 0017	endif
_eif19:

; 0018	wend
	jmp	_whl5
_wnd5:

; 0019	end sub
__swapper_end:
	mov	si,offset mr@cleanup_swapper
	call	_sub_cleanup
	ret	6
	mr@cleanup_swapper: dw s_9@REPLACEMENT,s_9@SYMBOL,s_9@TEMPLATE,s_9@SWAPLEFT,s_9@SWAPRIGHT,0
__swapper endp

; 0237	sub chop( cItem$ )
public __CHOP
__chop proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_10@CITEM],di

; 0238	s% = cinstr( cItem$, 32 )
	mov	si,word ptr ds:[s_10@CITEM]
	mov	cx,32
	call	_cinstr
	mov	word ptr ds:[w_10@S],ax

; 0239	if s% > 0 then
	test	ax,ax
	jg	short LL25
	jmp	_nif20
LL25:

; 0240	s% = s% - 1
	dec	word ptr ds:[w_10@S]

; 0241	chop_first$ = left( cItem$, s% )
	mov	bx,word ptr ds:[s_CHOP_FIRST]
	call	_mem_free
	mov	si,word ptr ds:[s_10@CITEM]
	mov	cx,ds:[w_10@S]
	call	_str_left
	mov	word ptr ds:[s_CHOP_FIRST],di

; 0242	s% = s% + 2
	add	word ptr ds:[w_10@S],2

; 0243	chop_second$ = mid( cItem$, s% )
	mov	bx,word ptr ds:[s_CHOP_SECOND]
	call	_mem_free
	mov	si,word ptr ds:[s_10@CITEM]
	mov	bx,word ptr ds:[w_10@S]
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_CHOP_SECOND],di

; 0244	else
	jmp	_eif20
_nif20:

; 0245	chop_first$ = cItem$
	mov	bx,word ptr ds:[s_CHOP_FIRST]
	call	_mem_free
	mov	si,word ptr ds:[s_10@CITEM]
	call	_str_copy
	mov	word ptr ds:[s_CHOP_FIRST],di

; 0246	chop_second$ = ""
	mov	bx,word ptr ds:[s_CHOP_SECOND]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_CHOP_SECOND],ax

; 0247	endif
_eif20:

; 0248	end sub
__chop_end:
	mov	si,offset mr@cleanup_chop
	call	_sub_cleanup
	ret	2
	mr@cleanup_chop: dw s_10@CITEM,0
__chop endp

; 0308	sub defvar( varname$, varval$ )
public __DEFVAR
__defvar proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_11@VARVAL],di
	mov	si,[bp+4]
	call	_str_copy
	mov	word ptr ds:[s_11@VARNAME],di

; 0309	vitem$ = varname$ + space( 20 )
	mov	bx,word ptr ds:[s_11@VITEM]
	call	_mem_free
	push	word ptr ds:[s_11@VARNAME]
	mov	cx,20
	call	_str_space
	call	_str_mark_di
	push	di
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s_11@VITEM],di
	call	_str_release

; 0310	vitem$ = left( vitem$, 20 )
	push	word ptr ds:[s_11@VITEM]
	mov	si,word ptr ds:[s_11@VITEM]
	mov	cx,20
	call	_str_left
	mov	word ptr ds:[s_11@VITEM],di
	pop	bx
	call	_mem_free

; 0311	vitem$ = vitem$ + varval$
	push	word ptr ds:[s_11@VITEM]
	push	word ptr ds:[s_11@VARVAL]
	mov	cx,2
	call	_str_mix
	mov	bx,word ptr ds:[s_11@VITEM]
	call	_mem_free
	mov	word ptr ds:[s_11@VITEM],di

; 0312	call getvaroffset( varname$ )
	push	word ptr ds:[s_11@VARNAME]
	call	__getvaroffset

; 0313	if varoffset% = 0 then
	cmp	word ptr ds:[w_VAROFFSET],0
	jz	short LL26
	jmp	_nif21
LL26:

; 0314	varcount% = varcount% + 1
	inc	word ptr ds:[w_VARCOUNT]

; 0315	varlist$[ varcount% ] = vitem$
	mov	bp,ds:[w_VARCOUNT]
	add	bp,bp
	mov	bx,word ptr ds:[bp+as_VARLIST]
	call	_mem_free
	mov	si,word ptr ds:[s_11@VITEM]
	call	_str_copy
	mov	word ptr ds:[bp+as_VARLIST],di

; 0316	else
	jmp	_eif21
_nif21:

; 0317	varlist$[ varoffset% ] = vitem$
	mov	bp,ds:[w_VAROFFSET]
	add	bp,bp
	mov	bx,word ptr ds:[bp+as_VARLIST]
	call	_mem_free
	mov	si,word ptr ds:[s_11@VITEM]
	call	_str_copy
	mov	word ptr ds:[bp+as_VARLIST],di

; 0318	endif
_eif21:

; 0319	end sub
__defvar_end:
	mov	si,offset mr@cleanup_defvar
	call	_sub_cleanup
	ret	4
	mr@cleanup_defvar: dw s_11@VARVAL,s_11@VARNAME,s_11@VITEM,0
__defvar endp

; 0321	sub getvar( varname$ ) ' result in common varvalue$
public __GETVAR
__getvar proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_12@VARNAME],di

; 0322	call getvaroffset( varname$ )
	push	word ptr ds:[s_12@VARNAME]
	call	__getvaroffset

; 0323	if varoffset% > 0 then
	cmp	word ptr ds:[w_VAROFFSET],0
	jg	short LL27
	jmp	_nif22
LL27:

; 0324	vline$ = varlist$[ varoffset% ]
	mov	bx,word ptr ds:[s_12@VLINE]
	call	_mem_free
	mov	bp,ds:[w_VAROFFSET]
	add	bp,bp
	mov	si,word ptr ds:[bp+as_VARLIST]
	call	_str_copy
	mov	word ptr ds:[s_12@VLINE],di

; 0325	varvalue$ = mid( vline$, 21 )
	mov	bx,word ptr ds:[s_VARVALUE]
	call	_mem_free
	mov	si,di
	mov	bx,21
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_VARVALUE],di

; 0326	else
	jmp	_eif22
_nif22:

; 0327	cErr$ = "Variable " + varname$ + " not defined."
	mov	bx,word ptr ds:[s_12@CERR]
	call	_mem_free
	mov	si,offset s_$SC_38
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_12@VARNAME]
	mov	si,offset s_$SC_39
	call	_str_cs_ds_mark
	push	si
	mov	cx,3
	call	_str_mix
	mov	word ptr ds:[s_12@CERR],di
	call	_str_release

; 0328	call defvar( "$ERROR", cErr$ )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_12@CERR]
	call	__defvar
	call	_str_release

; 0329	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0330	varvalue$ = ""
	mov	bx,word ptr ds:[s_VARVALUE]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_VARVALUE],ax

; 0331	endif
_eif22:

; 0332	end sub
__getvar_end:
	mov	si,offset mr@cleanup_getvar
	call	_sub_cleanup
	ret	2
	mr@cleanup_getvar: dw s_12@VARNAME,s_12@VLINE,s_12@CERR,0
__getvar endp

; 0334	sub VarNamevalue( offset% )
public __VARNAMEVALUE
__varnamevalue proc near
	mov	bp,sp
	mov	ax,[bp+2]
	mov	word ptr ds:[w_13@OFFSET],ax

; 0335	cTemp$ = varlist$[ offset% ]
	mov	bx,word ptr ds:[s_13@CTEMP]
	call	_mem_free
	mov	bp,ds:[w_13@OFFSET]
	add	bp,bp
	mov	si,word ptr ds:[bp+as_VARLIST]
	call	_str_copy
	mov	word ptr ds:[s_13@CTEMP],di

; 0336	Value$ = mid( cTemp$, 21 )
	mov	bx,word ptr ds:[s_VALUE]
	call	_mem_free
	mov	si,di
	mov	bx,21
	xor	cx,cx
	call	_str_mid
	mov	word ptr ds:[s_VALUE],di

; 0337	cTemp$ = left( cTemp$, 20 )
	push	word ptr ds:[s_13@CTEMP]
	mov	si,word ptr ds:[s_13@CTEMP]
	mov	cx,20
	call	_str_left
	mov	word ptr ds:[s_13@CTEMP],di
	pop	bx
	call	_mem_free

; 0338	cTemp$ = rtrim( cTemp$ )
	push	di
	mov	si,di
	call	_str_rtrim
	mov	word ptr ds:[s_13@CTEMP],di
	pop	bx
	call	_mem_free

; 0339	Variable$ = cTemp$
	mov	bx,word ptr ds:[s_VARIABLE]
	call	_mem_free
	mov	si,di
	call	_str_copy
	mov	word ptr ds:[s_VARIABLE],di

; 0340	end sub
__varnamevalue_end:
	mov	si,offset mr@cleanup_varnamevalue
	call	_sub_cleanup
	ret	2
	mr@cleanup_varnamevalue: dw s_13@CTEMP,0
__varnamevalue endp

; 0342	sub getvaroffset( vname$ )
public __GETVAROFFSET
__getvaroffset proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_14@VNAME],di

; 0343	gv_name$ = vname$ + space( 20 )
	mov	bx,word ptr ds:[s_14@GV_NAME]
	call	_mem_free
	push	word ptr ds:[s_14@VNAME]
	mov	cx,20
	call	_str_space
	call	_str_mark_di
	push	di
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s_14@GV_NAME],di
	call	_str_release

; 0344	gv_name$ = left( gv_name$, 20 )
	push	word ptr ds:[s_14@GV_NAME]
	mov	si,word ptr ds:[s_14@GV_NAME]
	mov	cx,20
	call	_str_left
	mov	word ptr ds:[s_14@GV_NAME],di
	pop	bx
	call	_mem_free

; 0345	varoffset% = 0
	xor	ax,ax
	mov	word ptr ds:[w_VAROFFSET],ax

; 0346	for i% = 1 to varcount%
	mov	word ptr ds:[w_14@I],1
_fornext2:

; 0347	gv_value$ = varlist$[ i% ]
	mov	bx,word ptr ds:[s_14@GV_VALUE]
	call	_mem_free
	mov	bp,ds:[w_14@I]
	add	bp,bp
	mov	si,word ptr ds:[bp+as_VARLIST]
	call	_str_copy
	mov	word ptr ds:[s_14@GV_VALUE],di

; 0348	gv_test$ = left( gv_value$, 20 )
	mov	bx,word ptr ds:[s_14@GV_TEST]
	call	_mem_free
	mov	si,di
	mov	cx,20
	call	_str_left
	mov	word ptr ds:[s_14@GV_TEST],di

; 0349	if gv_test$ = gv_name$ then
	mov	si,word ptr ds:[s_14@GV_NAME]
	call	_str_compare
	jz	short LL28
	jmp	_nif23
LL28:

; 0350	varoffset% = i%
	mov	ax,word ptr ds:[w_14@I]
	mov	word ptr ds:[w_VAROFFSET],ax

; 0351	exit for
	jmp	_fornext2end

; 0352	endif
_nif23:

; 0353	next
	mov	ax,word ptr ds:[w_14@I]
	inc	ax
	cmp	ax,ds:[w_VARCOUNT]
	jg	_fornext2end
	mov	word ptr ds:[w_14@I],ax
	jmp	_fornext2
_fornext2end:

; 0354	end sub
__getvaroffset_end:
	mov	si,offset mr@cleanup_getvaroffset
	call	_sub_cleanup
	ret	2
	mr@cleanup_getvaroffset: dw s_14@VNAME,s_14@GV_NAME,s_14@GV_VALUE,s_14@GV_TEST,0
__getvaroffset endp

; 0356	sub findlabel( lname$ )
public __FINDLABEL
__findlabel proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_15@LNAME],di

; 0357	found% = false
	xor	ax,ax
	mov	word ptr ds:[w_15@FOUND],ax

; 0358	for labelLine% = 1 to progMax%
	mov	word ptr ds:[w_15@LABELLINE],1
_fornext3:

; 0359	line$ = str( labelLine% )
	mov	bx,word ptr ds:[s_15@LINE]
	call	_mem_free
	mov	ax,word ptr ds:[w_15@LABELLINE]
	call	_words
	mov	word ptr ds:[s_15@LINE],di

; 0360	line$ = ltrim( line$ )
	push	di
	mov	si,di
	call	_str_ltrim
	mov	word ptr ds:[s_15@LINE],di
	pop	bx
	call	_mem_free

; 0361	line$ = "$LINE" + line$
	mov	si,offset s_$SC_19
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_15@LINE]
	mov	cx,2
	call	_str_mix
	mov	bx,word ptr ds:[s_15@LINE]
	call	_mem_free
	mov	word ptr ds:[s_15@LINE],di
	call	_str_release

; 0362	call getvar( line$ )
	push	word ptr ds:[s_15@LINE]
	call	__getvar

; 0363	inrec$ = varvalue$
	mov	bx,word ptr ds:[s_15@INREC]
	call	_mem_free
	mov	si,word ptr ds:[s_VARVALUE]
	call	_str_copy
	mov	word ptr ds:[s_15@INREC],di

; 0364	call chop( inrec$ )
	push	word ptr ds:[s_15@INREC]
	call	__chop

; 0365	chop_first$ = ucase( chop_first$ )
	push	word ptr ds:[s_CHOP_FIRST]
	mov	si,word ptr ds:[s_CHOP_FIRST]
	call	_str_ucase
	mov	word ptr ds:[s_CHOP_FIRST],di
	pop	bx
	call	_mem_free

; 0366	if chop_first$ = "LABEL" then
	mov	si,offset s_$SC_40
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL29
	jmp	_nif24
LL29:

; 0367	if chop_second$ = lname$ then
	mov	si,word ptr ds:[s_15@LNAME]
	mov	di,word ptr ds:[s_CHOP_SECOND]
	call	_str_compare
	jz	short LL30
	jmp	_nif25
LL30:

; 0368	if progLine% > labelLine% then
	mov	ax,word ptr ds:[w_PROGLINE]
	cmp	ax,ds:[w_15@LABELLINE]
	jg	short LL31
	jmp	_nif26
LL31:

; 0369	labelOffset% = progLine% - labelLine% * -1
	mov	ax,word ptr ds:[w_PROGLINE]
	sub	ax,ds:[w_15@LABELLINE]
	mov	bx,-1
	imul	bx
	mov	word ptr ds:[w_LABELOFFSET],ax

; 0370	else
	jmp	_eif26
_nif26:

; 0371	labelOffset% = labelLine% - progLine%
	mov	ax,word ptr ds:[w_15@LABELLINE]
	sub	ax,ds:[w_PROGLINE]
	mov	word ptr ds:[w_LABELOFFSET],ax

; 0372	endif
_eif26:

; 0373	found% = true
	mov	word ptr ds:[w_15@FOUND],-1

; 0374	exit for
	jmp	_fornext3end

; 0375	endif
_nif25:

; 0376	endif
_nif24:

; 0377	next
	mov	ax,word ptr ds:[w_15@LABELLINE]
	inc	ax
	cmp	ax,ds:[w_PROGMAX]
	jg	_fornext3end
	mov	word ptr ds:[w_15@LABELLINE],ax
	jmp	_fornext3
_fornext3end:

; 0378	if found% = false then
	cmp	word ptr ds:[w_15@FOUND],0
	jz	short LL32
	jmp	_nif27
LL32:

; 0379	cErrMsg$ = "Cannot find label " + lname$
	mov	bx,word ptr ds:[s_15@CERRMSG]
	call	_mem_free
	mov	si,offset s_$SC_41
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_15@LNAME]
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s_15@CERRMSG],di
	call	_str_release

; 0380	call defvar( "$ERROR", cErrMsg$ )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_15@CERRMSG]
	call	__defvar
	call	_str_release

; 0381	labelOffset% = 1
	mov	word ptr ds:[w_LABELOFFSET],1

; 0382	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0383	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0384	else
	jmp	_eif27
_nif27:

; 0385	errorflag% = false
	xor	ax,ax
	mov	word ptr ds:[w_ERRORFLAG],ax

; 0386	failure% = false
	mov	word ptr ds:[w_FAILURE],ax

; 0387	endif
_eif27:

; 0388	end sub
__findlabel_end:
	mov	si,offset mr@cleanup_findlabel
	call	_sub_cleanup
	ret	2
	mr@cleanup_findlabel: dw s_15@LNAME,s_15@LINE,s_15@INREC,s_15@CERRMSG,0
__findlabel endp

; 0390	#include yesno.sub

; 0001	sub yesno
public __YESNO
__yesno proc near

; 0002	flag% = true
	mov	word ptr ds:[w_16@FLAG],-1

; 0003	while flag%
_whl6:
	cmp	word ptr ds:[w_16@FLAG],-1
	jz	short LL33
	jmp	_wnd6
LL33:

; 0004	stop% = inkey()
	call	_inkey
	mov	word ptr ds:[w_16@STOP],ax

; 0005	if stop% > 0 then
	test	ax,ax
	jg	short LL34
	jmp	_nif28
LL34:

; 0006	if stop% = 13 then
	cmp	word ptr ds:[w_16@STOP],13
	jz	short LL35
	jmp	_nif29
LL35:

; 0007	stop% = 78 'N
	mov	word ptr ds:[w_16@STOP],78

; 0008	endif
_nif29:

; 0009	stopper$ = chr( stop% )
	mov	bx,word ptr ds:[s_16@STOPPER]
	call	_mem_free
	mov	bx,3
	call	_mem_alloc
	mov	word ptr ds:[di], 1
	mov	bl,byte ptr ds:[w_16@STOP]
	mov	byte ptr ds:[di+2],bl
	mov	word ptr ds:[s_16@STOPPER],di

; 0010	stopper$ = ucase( stopper$ )
	push	di
	mov	si,di
	call	_str_ucase
	mov	word ptr ds:[s_16@STOPPER],di
	pop	bx
	call	_mem_free

; 0011	if stopper$ = "Y" then
	cmp	word ptr ds:[di],1
	jnz	short LL36
	cmp	byte ptr ds:[di+2],89
	jz	short LL37
LL36:
	jmp	_nif30
LL37:

; 0012	exit while
	jmp	_wnd6

; 0013	endif
_nif30:

; 0014	if stopper$ = "N" then
	mov	di,word ptr ds:[s_16@STOPPER]
	cmp	word ptr ds:[di],1
	jnz	short LL38
	cmp	byte ptr ds:[di+2],78
	jz	short LL39
LL38:
	jmp	_nif31
LL39:

; 0015	exit while
	jmp	_wnd6

; 0016	endif
_nif31:

; 0017	print "\g"
	mov	di,offset s_$SC_44
	call	_echo_strconst

; 0018	endif
_nif28:

; 0019	wend
	jmp	_whl6
_wnd6:

; 0020	print stopper$ + "\n"
	mov	di,word ptr ds:[s_16@STOPPER]
	call	_tty_str_dos
	mov	di,offset s_$SC_21
	call	_echo_strconst

; 0021	if stopper$ = "Y" then
	mov	di,word ptr ds:[s_16@STOPPER]
	cmp	word ptr ds:[di],1
	jnz	short LL40
	cmp	byte ptr ds:[di+2],89
	jz	short LL41
LL40:
	jmp	_nif32
LL41:

; 0022	yesno_% = true
	mov	word ptr ds:[w_YESNO_],-1

; 0023	else
	jmp	_eif32
_nif32:

; 0024	yesno_% = false
	xor	ax,ax
	mov	word ptr ds:[w_YESNO_],ax

; 0025	endif
_eif32:

; 0027	end sub
__yesno_end:
	mov	si,offset mr@cleanup_yesno
	call	_sub_cleanup
	ret
	mr@cleanup_yesno: dw s_16@STOPPER,0
__yesno endp

; 0392	sub setyesno( flag% )
public __SETYESNO
__setyesno proc near
	mov	bp,sp
	mov	ax,[bp+2]
	mov	word ptr ds:[w_17@FLAG],ax

; 0393	if flag% = true then
	cmp	word ptr ds:[w_17@FLAG],-1
	jz	short LL42
	jmp	_nif33
LL42:

; 0394	Yes% = true
	mov	word ptr ds:[w_YES],-1

; 0395	No% = false
	xor	ax,ax
	mov	word ptr ds:[w_NO],ax

; 0396	else
	jmp	_eif33
_nif33:

; 0397	Yes% = false
	xor	ax,ax
	mov	word ptr ds:[w_YES],ax

; 0398	No% = true
	mov	word ptr ds:[w_NO],-1

; 0399	endif
_eif33:

; 0400	end sub
__setyesno_end:
	ret	2
__setyesno endp

; 0402	#include getdeept.sub

; 0001	sub getDeepestToken( line$, startmarker$, endmarker$ )
public __GETDEEPESTTOKEN
__getdeepesttoken proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_18@ENDMARKER],di
	mov	si,[bp+4]
	call	_str_copy
	mov	word ptr ds:[s_18@STARTMARKER],di
	mov	si,[bp+6]
	call	_str_copy
	mov	word ptr ds:[s_18@LINE],di

; 0002	depth% = 0
	xor	ax,ax
	mov	word ptr ds:[w_18@DEPTH],ax

; 0003	here% = 1
	mov	word ptr ds:[w_18@HERE],1

; 0004	itemstart% = 0
	xor	ax,ax
	mov	word ptr ds:[w_18@ITEMSTART],ax

; 0005	itemend% = 0
	mov	word ptr ds:[w_18@ITEMEND],ax

; 0006	max% = len( line$ )
	mov	bx,word ptr ds:[s_18@LINE]
	mov	ax,ds:[bx]
	mov	word ptr ds:[w_18@MAX],ax

; 0007	maxdepth% = 0
	xor	ax,ax
	mov	word ptr ds:[w_18@MAXDEPTH],ax

; 0008	forever% = true
	mov	word ptr ds:[w_18@FOREVER],-1

; 0009	deepestToken$ = ""
	mov	bx,word ptr ds:[s_DEEPESTTOKEN]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_DEEPESTTOKEN],ax

; 0010	while forever%
_whl7:
	cmp	word ptr ds:[w_18@FOREVER],-1
	jz	short LL43
	jmp	_wnd7
LL43:

; 0011	if here% > max% then
	mov	ax,word ptr ds:[w_18@HERE]
	cmp	ax,ds:[w_18@MAX]
	jg	short LL44
	jmp	_nif34
LL44:

; 0012	exit while
	jmp	_wnd7

; 0013	endif
_nif34:

; 0014	c$ = mid( line$, here%, 1 )
	mov	bx,word ptr ds:[s_18@C]
	call	_mem_free
	mov	si,word ptr ds:[s_18@LINE]
	mov	bx,word ptr ds:[w_18@HERE]
	mov	cx,1
	call	_str_mid
	mov	word ptr ds:[s_18@C],di

; 0015	#ifdef GETDEEPT

; 0017	#endif

; 0018	if c$ = startmarker$ then
	mov	si,word ptr ds:[s_18@STARTMARKER]
	call	_str_compare
	jz	short LL45
	jmp	_nif35
LL45:

; 0019	#ifdef GETDEEPT

; 0021	#endif

; 0022	#ifdef GETDEEPT

; 0024	#endif

; 0025	depth% = depth% + 1
	inc	word ptr ds:[w_18@DEPTH]

; 0026	if depth% > maxdepth% then
	mov	ax,word ptr ds:[w_18@DEPTH]
	cmp	ax,ds:[w_18@MAXDEPTH]
	jg	short LL46
	jmp	_nif36
LL46:

; 0027	maxdepth% = depth%
	mov	ax,word ptr ds:[w_18@DEPTH]
	mov	word ptr ds:[w_18@MAXDEPTH],ax

; 0028	itemstart% = here%
	mov	ax,word ptr ds:[w_18@HERE]
	mov	word ptr ds:[w_18@ITEMSTART],ax

; 0029	#ifdef GETDEEPT

; 0032	#endif

; 0033	endif
_nif36:

; 0034	endif
_nif35:

; 0036	if c$ = endmarker$ then
	mov	si,word ptr ds:[s_18@ENDMARKER]
	mov	di,word ptr ds:[s_18@C]
	call	_str_compare
	jz	short LL47
	jmp	_nif37
LL47:

; 0037	#ifdef GETDEEPT

; 0040	#endif

; 0041	if depth% = maxdepth% then
	mov	ax,word ptr ds:[w_18@DEPTH]
	cmp	ax,ds:[w_18@MAXDEPTH]
	jz	short LL48
	jmp	_nif38
LL48:

; 0042	itemend% = here%
	mov	ax,word ptr ds:[w_18@HERE]
	mov	word ptr ds:[w_18@ITEMEND],ax

; 0043	exit while
	jmp	_wnd7

; 0044	endif
_nif38:

; 0045	depth% = depth% - 1
	dec	word ptr ds:[w_18@DEPTH]

; 0046	endif
_nif37:

; 0047	here% = here% + 1
	inc	word ptr ds:[w_18@HERE]

; 0048	wend
	jmp	_whl7
_wnd7:

; 0049	if itemstart% > 0 then
	cmp	word ptr ds:[w_18@ITEMSTART],0
	jg	short LL49
	jmp	_nif39
LL49:

; 0050	itemstart% = itemstart% + 1
	inc	word ptr ds:[w_18@ITEMSTART]

; 0051	itemlen% = itemend% - itemstart%
	mov	ax,word ptr ds:[w_18@ITEMEND]
	sub	ax,ds:[w_18@ITEMSTART]
	mov	word ptr ds:[w_18@ITEMLEN],ax

; 0052	#ifdef GETDEEPT

; 0056	#endif

; 0057	if itemlen% = 0 then
	test	ax,ax
	jz	short LL50
	jmp	_nif40
LL50:

; 0058	deepestToken$ = ""
	mov	bx,word ptr ds:[s_DEEPESTTOKEN]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_DEEPESTTOKEN],ax

; 0059	else
	jmp	_eif40
_nif40:

; 0060	deepestToken$ = mid( line$, itemstart%, itemlen% )
	mov	bx,word ptr ds:[s_DEEPESTTOKEN]
	call	_mem_free
	mov	si,word ptr ds:[s_18@LINE]
	mov	bx,word ptr ds:[w_18@ITEMSTART]
	mov	cx,ds:[w_18@ITEMLEN]
	call	_str_mid
	mov	word ptr ds:[s_DEEPESTTOKEN],di

; 0061	endif
_eif40:

; 0062	else
	jmp	_eif39
_nif39:

; 0063	deepestToken$ = ""
	mov	bx,word ptr ds:[s_DEEPESTTOKEN]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[s_DEEPESTTOKEN],ax

; 0064	endif
_eif39:

; 0065	end sub
__getdeepesttoken_end:
	mov	si,offset mr@cleanup_getdeepesttoken
	call	_sub_cleanup
	ret	6
	mr@cleanup_getdeepesttoken: dw s_18@ENDMARKER,s_18@STARTMARKER,s_18@LINE,s_18@C,0
__getdeepesttoken endp

; 0404	sub debug( onething$, twothing$ )
public __DEBUG
__debug proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_19@TWOTHING],di
	mov	si,[bp+4]
	call	_str_copy
	mov	word ptr ds:[s_19@ONETHING],di

; 0405	if debugging% = true then print onething$ + twothing$ + "\n"
	cmp	word ptr ds:[w_DEBUGGING],-1
	jz	short LL51
	jmp	_nif41
LL51:
	mov	di,word ptr ds:[s_19@ONETHING]
	call	_tty_str_dos
	mov	di,word ptr ds:[s_19@TWOTHING]
	call	_tty_str_dos
	mov	di,offset s_$SC_21
	call	_echo_strconst
_nif41:

; 0406	end sub
__debug_end:
	mov	si,offset mr@cleanup_debug
	call	_sub_cleanup
	ret	4
	mr@cleanup_debug: dw s_19@TWOTHING,s_19@ONETHING,0
__debug endp

; 0408	sub process( kwd$, rest$ )
public __PROCESS
__process proc near
	mov	bp,sp
	mov	si,[bp+2]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di
	mov	si,[bp+4]
	call	_str_copy
	mov	word ptr ds:[s_20@KWD],di

; 0409	call debug( "process: ",kwd$ )
	mov	si,offset s_$SC_45
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@KWD]
	call	__debug
	call	_str_release

; 0410	kwd$ = ucase( kwd$ )
	push	word ptr ds:[s_20@KWD]
	mov	si,word ptr ds:[s_20@KWD]
	call	_str_ucase
	mov	word ptr ds:[s_20@KWD],di
	pop	bx
	call	_mem_free

; 0411	select case kwd$
	

; 0413	case "DEBUG"
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_46
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_0
	jmp	_clst1_1
_cont1_0:

; 0414	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0415	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0416	rest$ = ucase( rest$ )
	push	di
	mov	si,di
	call	_str_ucase
	mov	word ptr ds:[s_20@REST],di
	pop	bx
	call	_mem_free

; 0417	if rest$ = "ON" then
	mov	si,offset s_$SC_47
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL52
	jmp	_nif42
LL52:

; 0418	debugging% = true
	mov	word ptr ds:[w_DEBUGGING],-1

; 0419	else
	jmp	_eif42
_nif42:

; 0420	if rest$ = "OFF" then
	mov	si,offset s_$SC_48
	call	_str_cs_ds
	push	si
	mov	di,word ptr ds:[s_20@REST]
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL53
	jmp	_nif43
LL53:

; 0421	debugging% = false
	xor	ax,ax
	mov	word ptr ds:[w_DEBUGGING],ax

; 0422	else
	jmp	_eif43
_nif43:

; 0423	call defvar( "$ERROR", "DEBUG neither ON nor OFF" )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	mov	si,offset s_$SC_49
	call	_str_cs_ds_mark
	push	si
	call	__defvar
	call	_str_release

; 0424	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0425	endif
_eif43:

; 0426	endif
_eif42:

; 0428	case "MESSAGES"
	jmp	_clst1_end
_clst1_1:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_50
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_1
	jmp	_clst1_2
_cont1_1:

; 0429	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0430	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0431	rest$ = ucase( rest$ )
	push	di
	mov	si,di
	call	_str_ucase
	mov	word ptr ds:[s_20@REST],di
	pop	bx
	call	_mem_free

; 0432	if rest$ = "ON" then
	mov	si,offset s_$SC_47
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL54
	jmp	_nif44
LL54:

; 0433	messages% = true
	mov	word ptr ds:[w_MESSAGES],-1

; 0434	else
	jmp	_eif44
_nif44:

; 0435	if rest$ = "OFF" then
	mov	si,offset s_$SC_48
	call	_str_cs_ds
	push	si
	mov	di,word ptr ds:[s_20@REST]
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL55
	jmp	_nif45
LL55:

; 0436	messages% = false
	xor	ax,ax
	mov	word ptr ds:[w_MESSAGES],ax

; 0437	else
	jmp	_eif45
_nif45:

; 0438	call defvar( "$ERROR", "MESSAGES neither ON nor OFF" )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	mov	si,offset s_$SC_51
	call	_str_cs_ds_mark
	push	si
	call	__defvar
	call	_str_release

; 0439	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0440	endif
_eif45:

; 0441	endif
_eif44:

; 0443	case "CONSIDERING"
	jmp	_clst1_end
_clst1_2:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_52
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_2
	jmp	_clst1_3
_cont1_2:

; 0444	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0445	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0446	rest$ = ucase( rest$ )
	push	di
	mov	si,di
	call	_str_ucase
	mov	word ptr ds:[s_20@REST],di
	pop	bx
	call	_mem_free

; 0447	if rest$ = "CASE" then
	mov	si,offset s_$SC_53
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL56
	jmp	_nif46
LL56:

; 0448	caseSens% = true
	mov	word ptr ds:[w_CASESENS],-1

; 0449	endif
_nif46:

; 0451	case "IGNORING"
	jmp	_clst1_end
_clst1_3:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_54
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_3
	jmp	_clst1_4
_cont1_3:

; 0452	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0453	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0454	rest$ = ucase( rest$ )
	push	di
	mov	si,di
	call	_str_ucase
	mov	word ptr ds:[s_20@REST],di
	pop	bx
	call	_mem_free

; 0455	if rest$ = "CASE" then
	mov	si,offset s_$SC_53
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	pushf
	call	_mem_free
	popf
	jz	short LL57
	jmp	_nif47
LL57:

; 0456	caseSens% = false
	xor	ax,ax
	mov	word ptr ds:[w_CASESENS],ax

; 0457	endif
_nif47:

; 0459	case "TRANSLATION"
	jmp	_clst1_end
_clst1_4:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_55
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_4
	jmp	_clst1_5
_cont1_4:

; 0460	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0461	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0462	rest$ = ucase( rest$ )
	push	di
	mov	si,di
	call	_str_ucase
	mov	word ptr ds:[s_20@REST],di
	pop	bx
	call	_mem_free

; 0463	translation% = val( rest$ )
	mov	si,word ptr ds:[s_20@REST]
	call	_ival
	mov	word ptr ds:[w_TRANSLATION],ax

; 0465	case "MESSAGE"
	jmp	_clst1_end
_clst1_5:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_56
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_5
	jmp	_clst1_6
_cont1_5:

; 0466	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0467	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0468	call swapper( rest$, "\\n", CRLF$ )
	push	word ptr ds:[s_20@REST]
	mov	si,offset s_$SC_57
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_CRLF]
	call	__swapper
	call	_str_release

; 0469	print  swapped$
	mov	di,word ptr ds:[s_SWAPPED]
	call	_tty_str_dos

; 0470	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0472	case "DUMP" ' output file in rest$
	jmp	_clst1_end
_clst1_6:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_58
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_6
	jmp	_clst1_7
_cont1_6:

; 0473	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0474	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0475	h% = fcreate( rest$, archive )
	mov	si,di
	mov	cx,020h
	call	_file_create
	mov	word ptr ds:[w_20@H],ax

; 0476	for i% = 1 to varcount%
	mov	word ptr ds:[w_20@I],1
_fornext4:

; 0477	call varnamevalue( i% )
	push	word ptr ds:[w_20@I]
	call	__varnamevalue

; 0478	fprint( h%, variable$ + "=" + value$ + "\n" )
	push	word ptr ds:[s_VARIABLE]
	mov	si,offset s_$SC_59
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_VALUE]
	mov	si,offset s_$SC_21
	call	_str_cs_ds_mark
	push	si
	mov	cx,4
	call	_str_mix
	mov	bx,word ptr ds:[w_20@H]
	call	_str_mark_di
	call	_file_print
	call	_str_release

; 0479	next
	mov	ax,word ptr ds:[w_20@I]
	inc	ax
	cmp	ax,ds:[w_VARCOUNT]
	jg	_fornext4end
	mov	word ptr ds:[w_20@I],ax
	jmp	_fornext4
_fornext4end:

; 0480	fclose( h% )
	mov	bx,word ptr ds:[w_20@H]
	call	_file_close

; 0481	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0483	case "SET" ' set var value
	jmp	_clst1_end
_clst1_7:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_60
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_7
	jmp	_clst1_8
_cont1_7:

; 0484	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0485	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0486	call chop( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__chop

; 0487	call getvaroffset( chop_first$ )
	push	word ptr ds:[s_CHOP_FIRST]
	call	__getvaroffset

; 0488	if varoffset% > 0 then
	cmp	word ptr ds:[w_VAROFFSET],0
	jg	short LL58
	jmp	_nif48
LL58:

; 0489	call defvar( chop_first$, chop_second$ )
	push	word ptr ds:[s_CHOP_FIRST]
	push	word ptr ds:[s_CHOP_SECOND]
	call	__defvar

; 0490	else
	jmp	_eif48
_nif48:

; 0491	cErr$ = "Cannot SET undefined variable " + chop_first$ + "."
	mov	bx,word ptr ds:[s_20@CERR]
	call	_mem_free
	mov	si,offset s_$SC_61
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_CHOP_FIRST]
	mov	si,offset s_$SC_62
	call	_str_cs_ds_mark
	push	si
	mov	cx,3
	call	_str_mix
	mov	word ptr ds:[s_20@CERR],di
	call	_str_release

; 0492	call defvar( "$ERROR", cErr$ )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@CERR]
	call	__defvar
	call	_str_release

; 0493	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0494	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0495	endif
_eif48:

; 0497	case "END"
	jmp	_clst1_end
_clst1_8:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_63
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_8
	jmp	_clst1_9
_cont1_8:

; 0498	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0499	rest$ = "MESSAGE " + Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,offset s_$SC_64
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SUBST]
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s_20@REST],di
	call	_str_release

; 0500	call parse( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__parse

; 0501	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0502	call defvar( "$DONE", "TRUE" )
	mov	si,offset s_$SC_7
	call	_str_cs_ds_mark
	push	si
	mov	si,offset s_$SC_26
	call	_str_cs_ds_mark
	push	si
	call	__defvar
	call	_str_release

; 0504	case "BEEP"
	jmp	_clst1_end
_clst1_9:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_65
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_9
	jmp	_clst1_10
_cont1_9:

; 0505	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0506	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0507	nTimes% = val( rest$ )
	mov	si,word ptr ds:[s_20@REST]
	call	_ival
	mov	word ptr ds:[w_20@NTIMES],ax

; 0508	if nTimes% = 0 then nTimes% = 1
	test	ax,ax
	jz	short LL59
	jmp	_nif49
LL59:
	mov	word ptr ds:[w_20@NTIMES],1
_nif49:

; 0509	for i% = 1 to nTimes%
	mov	word ptr ds:[w_20@I],1
_fornext5:

; 0510	print "\g"
	mov	di,offset s_$SC_44
	call	_echo_strconst

; 0511	next
	mov	ax,word ptr ds:[w_20@I]
	inc	ax
	cmp	ax,ds:[w_20@NTIMES]
	jg	_fornext5end
	mov	word ptr ds:[w_20@I],ax
	jmp	_fornext5
_fornext5end:

; 0512	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0514	case "DO"
	jmp	_clst1_end
_clst1_10:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_66
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_10
	jmp	_clst1_11
_cont1_10:

; 0515	call Substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0516	rest$ = Subst$
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	si,word ptr ds:[s_SUBST]
	call	_str_copy
	mov	word ptr ds:[s_20@REST],di

; 0517	call chop( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__chop

; 0518	nRes% = exec( chop_first$, chop_second$ )
	mov	di,word ptr ds:[s_CHOP_SECOND]
	mov	si,word ptr ds:[s_CHOP_FIRST]
	call	_exec
	mov	word ptr ds:[w_20@NRES],ax

; 0519	cRes$ = str( nRes% )
	mov	bx,word ptr ds:[s_20@CRES]
	call	_mem_free
	mov	ax,word ptr ds:[w_20@NRES]
	call	_words
	mov	word ptr ds:[s_20@CRES],di

; 0520	call defvar( "$EXEC", cRes$ )
	mov	si,offset s_$SC_4
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@CRES]
	call	__defvar
	call	_str_release

; 0521	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0523	case "INPUT"
	jmp	_clst1_end
_clst1_11:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_67
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_11
	jmp	_clst1_12
_cont1_11:

; 0525	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0526	subst$ = "MESSAGE " + subst$ + " "
	mov	si,offset s_$SC_64
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SUBST]
	mov	si,offset s_$SC_68
	call	_str_cs_ds_mark
	push	si
	mov	cx,3
	call	_str_mix
	mov	bx,word ptr ds:[s_SUBST]
	call	_mem_free
	mov	word ptr ds:[s_SUBST],di
	call	_str_release

; 0527	call parse( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__parse

; 0529	input( temp$ )
	mov	bx,word ptr ds:[s_20@TEMP]
	call	_mem_free
	mov	bx,78
	mov	cl,' '
	call	_keyboard_input
	mov	word ptr ds:[s_20@TEMP],di

; 0530	print "\n"
	mov	di,offset s_$SC_21
	call	_echo_strconst

; 0531	call defvar( "$INPUT", temp$ )
	mov	si,offset s_$SC_5
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@TEMP]
	call	__defvar
	call	_str_release

; 0532	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0534	case "GOTO"
	jmp	_clst1_end
_clst1_12:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_69
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_12
	jmp	_clst1_13
_cont1_12:

; 0535	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0536	call findlabel( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__findlabel

; 0537	progIncr% = labelOffset%
	mov	ax,word ptr ds:[w_LABELOFFSET]
	mov	word ptr ds:[w_PROGINCR],ax

; 0539	case "LABEL" 'ignore
	jmp	_clst1_end
_clst1_13:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_40
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_13
	jmp	_clst1_14
_cont1_13:

; 0541	case "IFYES"
	jmp	_clst1_end
_clst1_14:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_70
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_14
	jmp	_clst1_15
_cont1_14:

; 0542	if Yes% = true then
	cmp	word ptr ds:[w_YES],-1
	jz	short LL60
	jmp	_nif50
LL60:

; 0543	Yes% = false
	xor	ax,ax
	mov	word ptr ds:[w_YES],ax

; 0544	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0545	call parse( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__parse

; 0546	endif
_nif50:

; 0548	case "IFNO"
	jmp	_clst1_end
_clst1_15:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_71
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_15
	jmp	_clst1_16
_cont1_15:

; 0549	if No% = true then
	cmp	word ptr ds:[w_NO],-1
	jz	short LL61
	jmp	_nif51
LL61:

; 0550	No% = false
	xor	ax,ax
	mov	word ptr ds:[w_NO],ax

; 0551	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0552	call parse( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__parse

; 0553	endif
_nif51:

; 0555	case "EXISTS"
	jmp	_clst1_end
_clst1_16:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_72
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_16
	jmp	_clst1_17
_cont1_16:

; 0556	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0557	exist% = fexist( subst$, 7 )
	mov	si,word ptr ds:[s_SUBST]
	mov	cx,7
	call	_file_exist
	mov	word ptr ds:[w_20@EXIST],ax

; 0558	call setyesno( exist% )
	push	word ptr ds:[w_20@EXIST]
	call	__setyesno

; 0560	case "YESNO"
	jmp	_clst1_end
_clst1_17:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_73
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_17
	jmp	_clst1_18
_cont1_17:

; 0561	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0562	rest$ = "MESSAGE " + rest$
	mov	si,offset s_$SC_64
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@REST]
	mov	cx,2
	call	_str_mix
	mov	bx,word ptr ds:[s_20@REST]
	call	_mem_free
	mov	word ptr ds:[s_20@REST],di
	call	_str_release

; 0563	call parse( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__parse

; 0564	call yesno
	call	__yesno

; 0565	call setyesno( yesno_% )
	push	word ptr ds:[w_YESNO_]
	call	__setyesno

; 0567	case "OPEN"
	jmp	_clst1_end
_clst1_18:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_74
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_18
	jmp	_clst1_19
_cont1_18:

; 0568	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0569	temp$ = "EXISTS " + rest$
	mov	bx,word ptr ds:[s_20@TEMP]
	call	_mem_free
	mov	si,offset s_$SC_75
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@REST]
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s_20@TEMP],di
	call	_str_release

; 0570	call parse( temp$ )
	push	word ptr ds:[s_20@TEMP]
	call	__parse

; 0571	if Yes% = true then
	cmp	word ptr ds:[w_YES],-1
	jz	short LL62
	jmp	_nif52
LL62:

; 0572	fileHandle% = fopen( subst$, readwrite )
	mov	si,word ptr ds:[s_SUBST]
	mov	cx,02h
	call	_file_open
	mov	word ptr ds:[w_FILEHANDLE],ax

; 0573	call defvar( "$OPEN", subst$ )
	mov	si,offset s_$SC_6
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SUBST]
	call	__defvar
	call	_str_release

; 0574	else
	jmp	_eif52
_nif52:

; 0575	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0576	endif
_eif52:

; 0578	case "CREATE"
	jmp	_clst1_end
_clst1_19:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_76
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_19
	jmp	_clst1_20
_cont1_19:

; 0579	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0580	fileHandle% = fcreate( subst$, archive )
	mov	si,word ptr ds:[s_SUBST]
	mov	cx,020h
	call	_file_create
	mov	word ptr ds:[w_FILEHANDLE],ax

; 0581	call defvar( "$OPEN", subst$ )
	mov	si,offset s_$SC_6
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SUBST]
	call	__defvar
	call	_str_release

; 0583	case "WRITE"
	jmp	_clst1_end
_clst1_20:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_77
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_20
	jmp	_clst1_21
_cont1_20:

; 0584	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0585	call getvar( "$OPEN" )
	mov	si,offset s_$SC_6
	call	_str_cs_ds_mark
	push	si
	call	__getvar
	call	_str_release

; 0586	if varvalue$ = "" then
	mov	si,word ptr ds:[s_VARVALUE]
	mov	cx,ds:[si]
	jcxz	short LL63
	jmp	_nif53
LL63:

; 0587	cErrMsg$ = "Cannot write to an unopen file."
	mov	bx,word ptr ds:[s_20@CERRMSG]
	call	_mem_free
	mov	si,offset s_$SC_78
	call	_str_cs_ds
	mov	word ptr ds:[s_20@CERRMSG],si

; 0588	call defvar( "$ERROR", cErrMsg$ )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@CERRMSG]
	call	__defvar
	call	_str_release

; 0589	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0590	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0591	else
	jmp	_eif53
_nif53:

; 0592	call swapper( subst$, "\\n", CRLF$ )
	push	word ptr ds:[s_SUBST]
	mov	si,offset s_$SC_57
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_CRLF]
	call	__swapper
	call	_str_release

; 0593	fprint( fileHandle%, swapped$ )
	mov	si,word ptr ds:[s_SWAPPED]
	call	_str_copy
	mov	bx,word ptr ds:[w_FILEHANDLE]
	push	di
	call	_file_print
	pop	bx
	call	_mem_free

; 0594	endif
_eif53:

; 0596	case "READ"
	jmp	_clst1_end
_clst1_21:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_79
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_21
	jmp	_clst1_22
_cont1_21:

; 0597	call getvar( "$OPEN" )
	mov	si,offset s_$SC_6
	call	_str_cs_ds_mark
	push	si
	call	__getvar
	call	_str_release

; 0598	if varvalue$ = "" then
	mov	si,word ptr ds:[s_VARVALUE]
	mov	cx,ds:[si]
	jcxz	short LL64
	jmp	_nif54
LL64:

; 0599	cErrMsg$ = "Cannot read from an unopened file."
	mov	bx,word ptr ds:[s_20@CERRMSG]
	call	_mem_free
	mov	si,offset s_$SC_80
	call	_str_cs_ds
	mov	word ptr ds:[s_20@CERRMSG],si

; 0600	call defvar( "$ERROR", cErrMsg$ )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@CERRMSG]
	call	__defvar
	call	_str_release

; 0601	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0602	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0603	else
	jmp	_eif54
_nif54:

; 0604	finput( fileHandle%, temp$ )
	mov	bx,word ptr ds:[s_20@TEMP]
	call	_mem_free
	mov	bx,word ptr ds:[w_FILEHANDLE]
	call	_finput
	mov	word ptr ds:[s_20@TEMP],di

; 0605	if feof( fileHandle% ) = true then
	mov	bx,word ptr ds:[w_FILEHANDLE]
	call	_file_eof
	cmp	ax,-1
	jz	short LL65
	jmp	_nif55
LL65:

; 0606	call defvar( "$ERROR", "End of file." )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	mov	si,offset s_$SC_81
	call	_str_cs_ds_mark
	push	si
	call	__defvar
	call	_str_release

; 0607	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0608	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0609	else
	jmp	_eif55
_nif55:

; 0610	call defvar( "$INPUT", temp$ )
	mov	si,offset s_$SC_5
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@TEMP]
	call	__defvar
	call	_str_release

; 0611	endif
_eif55:

; 0612	endif
_eif54:

; 0614	case "CLOSE"
	jmp	_clst1_end
_clst1_22:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_82
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_22
	jmp	_clst1_23
_cont1_22:

; 0615	call getvar( "$OPEN" )
	mov	si,offset s_$SC_6
	call	_str_cs_ds_mark
	push	si
	call	__getvar
	call	_str_release

; 0616	if varvalue$ = "" then
	mov	si,word ptr ds:[s_VARVALUE]
	mov	cx,ds:[si]
	jcxz	short LL66
	jmp	_nif56
LL66:

; 0617	cErrMsg$ = "Cannot close a file that is not open."
	mov	bx,word ptr ds:[s_20@CERRMSG]
	call	_mem_free
	mov	si,offset s_$SC_83
	call	_str_cs_ds
	mov	word ptr ds:[s_20@CERRMSG],si

; 0618	call defvar( "$ERROR", cErrMsg$ )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@CERRMSG]
	call	__defvar
	call	_str_release

; 0619	errorflag% = true
	mov	word ptr ds:[w_ERRORFLAG],-1

; 0620	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0621	else
	jmp	_eif56
_nif56:

; 0622	fclose( fileHandle% )
	mov	bx,word ptr ds:[w_FILEHANDLE]
	call	_file_close

; 0623	call defvar( "$OPEN", "" )
	mov	si,offset s_$SC_6
	call	_str_cs_ds_mark
	push	si
	xor	ax,ax
	push	ax
	call	__defvar
	call	_str_release

; 0624	endif
_eif56:

; 0626	case "IFFAIL"
	jmp	_clst1_end
_clst1_23:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_84
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_23
	jmp	_clst1_24
_cont1_23:

; 0627	if failure% = true then
	cmp	word ptr ds:[w_FAILURE],-1
	jz	short LL67
	jmp	_nif57
LL67:

; 0628	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0629	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0630	call parse( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__parse

; 0631	endif
_nif57:

; 0633	case "TEST"
	jmp	_clst1_end
_clst1_24:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_85
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_24
	jmp	_clst1_25
_cont1_24:

; 0634	call chop( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__chop

; 0635	compar$ = ucase( chop_first$ )
	mov	bx,word ptr ds:[s_20@COMPAR]
	call	_mem_free
	mov	si,word ptr ds:[s_CHOP_FIRST]
	call	_str_ucase
	mov	word ptr ds:[s_20@COMPAR],di

; 0636	call chop( chop_second$ )
	push	word ptr ds:[s_CHOP_SECOND]
	call	__chop

; 0637	call substitute( chop_first$ )
	push	word ptr ds:[s_CHOP_FIRST]
	call	__substitute

; 0638	lh$ = "[" + subst$ + "]"
	mov	bx,word ptr ds:[s_20@LH]
	call	_mem_free
	mov	si,offset s_$SC_86
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SUBST]
	mov	si,offset s_$SC_87
	call	_str_cs_ds_mark
	push	si
	mov	cx,3
	call	_str_mix
	mov	word ptr ds:[s_20@LH],di
	call	_str_release

; 0639	_lh% = val( subst$ )
	mov	si,word ptr ds:[s_SUBST]
	call	_ival
	mov	word ptr ds:[w_20@_LH],ax

; 0640	call substitute( chop_second$ )
	push	word ptr ds:[s_CHOP_SECOND]
	call	__substitute

; 0641	rh$ = "[" + subst$ + "]"
	mov	bx,word ptr ds:[s_20@RH]
	call	_mem_free
	mov	si,offset s_$SC_86
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_SUBST]
	mov	si,offset s_$SC_87
	call	_str_cs_ds_mark
	push	si
	mov	cx,3
	call	_str_mix
	mov	word ptr ds:[s_20@RH],di
	call	_str_release

; 0642	_rh% = val( subst$ )
	mov	si,word ptr ds:[s_SUBST]
	call	_ival
	mov	word ptr ds:[w_20@_RH],ax

; 0643	if caseSens% = false then
	cmp	word ptr ds:[w_CASESENS],0
	jz	short LL68
	jmp	_nif58
LL68:

; 0644	lh$ = ucase( lh$ )
	push	word ptr ds:[s_20@LH]
	mov	si,word ptr ds:[s_20@LH]
	call	_str_ucase
	mov	word ptr ds:[s_20@LH],di
	pop	bx
	call	_mem_free

; 0645	rh$ = ucase( rh$ )
	push	word ptr ds:[s_20@RH]
	mov	si,word ptr ds:[s_20@RH]
	call	_str_ucase
	mov	word ptr ds:[s_20@RH],di
	pop	bx
	call	_mem_free

; 0646	endif
_nif58:

; 0647	call debug( "test: lh$=", lh$ )
	mov	si,offset s_$SC_88
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@LH]
	call	__debug
	call	_str_release

; 0648	call debug( "test: rh$=", rh$ )
	mov	si,offset s_$SC_89
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@RH]
	call	__debug
	call	_str_release

; 0649	testRes% = false
	xor	ax,ax
	mov	word ptr ds:[w_20@TESTRES],ax

; 0650	select case compar$
	

; 0651	case "EQS"
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_90
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_0
	jmp	_clst2_1
_cont2_0:

; 0652	if lh$ = rh$ then
	mov	si,word ptr ds:[s_20@RH]
	mov	di,word ptr ds:[s_20@LH]
	call	_str_compare
	jz	short LL69
	jmp	_nif59
LL69:

; 0653	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0654	endif
_nif59:

; 0655	case "LTS"
	jmp	_clst2_end
_clst2_1:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_91
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_1
	jmp	_clst2_2
_cont2_1:

; 0656	if lh$ < rh$ then
	mov	si,word ptr ds:[s_20@RH]
	mov	di,word ptr ds:[s_20@LH]
	call	_str_compare
	jb	short LL70
	jmp	_nif60
LL70:

; 0657	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0658	endif
_nif60:

; 0659	case "LES"
	jmp	_clst2_end
_clst2_2:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_92
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_2
	jmp	_clst2_3
_cont2_2:

; 0660	if lh$ <= rh$ then
	mov	si,word ptr ds:[s_20@RH]
	mov	di,word ptr ds:[s_20@LH]
	call	_str_compare
	jbe	short LL71
	jmp	_nif61
LL71:

; 0661	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0662	endif
_nif61:

; 0663	case "GES"
	jmp	_clst2_end
_clst2_3:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_93
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_3
	jmp	_clst2_4
_cont2_3:

; 0664	if lh$ >= rh$ then
	mov	si,word ptr ds:[s_20@RH]
	mov	di,word ptr ds:[s_20@LH]
	call	_str_compare
	jae	short LL72
	jmp	_nif62
LL72:

; 0665	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0666	endif
_nif62:

; 0667	case "GTS"
	jmp	_clst2_end
_clst2_4:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_94
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_4
	jmp	_clst2_5
_cont2_4:

; 0668	if lh$ > rh$ then
	mov	si,word ptr ds:[s_20@RH]
	mov	di,word ptr ds:[s_20@LH]
	call	_str_compare
	ja	short LL73
	jmp	_nif63
LL73:

; 0669	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0670	endif
_nif63:

; 0671	case "NES"
	jmp	_clst2_end
_clst2_5:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_95
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_5
	jmp	_clst2_6
_cont2_5:

; 0672	if lh$ <> rh$ then
	mov	si,word ptr ds:[s_20@RH]
	mov	di,word ptr ds:[s_20@LH]
	call	_str_compare
	jnz	short LL74
	jmp	_nif64
LL74:

; 0673	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0674	endif
_nif64:

; 0675	case "EQ"
	jmp	_clst2_end
_clst2_6:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_96
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_6
	jmp	_clst2_7
_cont2_6:

; 0676	if _lh% = _rh% then
	mov	ax,word ptr ds:[w_20@_LH]
	cmp	ax,ds:[w_20@_RH]
	jz	short LL75
	jmp	_nif65
LL75:

; 0677	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0678	endif
_nif65:

; 0679	case "LT"
	jmp	_clst2_end
_clst2_7:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_97
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_7
	jmp	_clst2_8
_cont2_7:

; 0680	if _lh% < _rh% then
	mov	ax,word ptr ds:[w_20@_LH]
	cmp	ax,ds:[w_20@_RH]
	jl	short LL76
	jmp	_nif66
LL76:

; 0681	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0682	endif
_nif66:

; 0683	case "LE"
	jmp	_clst2_end
_clst2_8:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_98
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_8
	jmp	_clst2_9
_cont2_8:

; 0684	if _lh% <= _rh% then
	mov	ax,word ptr ds:[w_20@_LH]
	cmp	ax,ds:[w_20@_RH]
	jle	short LL77
	jmp	_nif67
LL77:

; 0685	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0686	endif
_nif67:

; 0687	case "GE"
	jmp	_clst2_end
_clst2_9:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_99
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_9
	jmp	_clst2_10
_cont2_9:

; 0688	if _lh% >= _rh% then
	mov	ax,word ptr ds:[w_20@_LH]
	cmp	ax,ds:[w_20@_RH]
	jge	short LL78
	jmp	_nif68
LL78:

; 0689	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0690	endif
_nif68:

; 0691	case "GT"
	jmp	_clst2_end
_clst2_10:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_100
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_10
	jmp	_clst2_11
_cont2_10:

; 0692	if _lh% > _rh% then
	mov	ax,word ptr ds:[w_20@_LH]
	cmp	ax,ds:[w_20@_RH]
	jg	short LL79
	jmp	_nif69
LL79:

; 0693	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0694	endif
_nif69:

; 0695	case "NE"
	jmp	_clst2_end
_clst2_11:
	mov	di,word ptr ds:[s_20@COMPAR]
	mov	si,offset s_$SC_101
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont2_11
	jmp	_clst2_12
_cont2_11:

; 0696	if _lh% <> _rh% then
	mov	ax,word ptr ds:[w_20@_LH]
	cmp	ax,ds:[w_20@_RH]
	jnz	short LL80
	jmp	_nif70
LL80:

; 0697	testRes% = true
	mov	word ptr ds:[w_20@TESTRES],-1

; 0698	endif
_nif70:

; 0699	end select
_clst2_end:
_clst2_12:

; 0700	call setyesno( testRes% )
	push	word ptr ds:[w_20@TESTRES]
	call	__setyesno

; 0702	case "INC"
	jmp	_clst1_end
_clst1_25:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_102
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_25
	jmp	_clst1_26
_cont1_25:

; 0703	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0704	call chop( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__chop

; 0705	call getvar( chop_first$ )
	push	word ptr ds:[s_CHOP_FIRST]
	call	__getvar

; 0706	amount% = val( chop_second$ )
	mov	si,word ptr ds:[s_CHOP_SECOND]
	call	_ival
	mov	word ptr ds:[w_20@AMOUNT],ax

; 0707	current% = val( varvalue$ )
	mov	si,word ptr ds:[s_VARVALUE]
	call	_ival
	mov	word ptr ds:[w_20@CURRENT],ax

; 0708	current% = current% + amount%
	mov	ax,word ptr ds:[w_20@AMOUNT]
	add	ds:[w_20@CURRENT],ax

; 0709	temp$ = str( current% )
	mov	bx,word ptr ds:[s_20@TEMP]
	call	_mem_free
	mov	ax,word ptr ds:[w_20@CURRENT]
	call	_words
	mov	word ptr ds:[s_20@TEMP],di

; 0710	call defvar( chop_first$, temp$ )
	push	word ptr ds:[s_CHOP_FIRST]
	push	word ptr ds:[s_20@TEMP]
	call	__defvar

; 0712	case "KEYPRESSED"
	jmp	_clst1_end
_clst1_26:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_103
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_26
	jmp	_clst1_27
_cont1_26:

; 0713	flag% = false
	xor	ax,ax
	mov	word ptr ds:[w_20@FLAG],ax

; 0714	if inkey() <> -1 then
	call	_inkey
	cmp	ax,-1
	jnz	short LL81
	jmp	_nif71
LL81:

; 0715	flag% = true
	mov	word ptr ds:[w_20@FLAG],-1

; 0716	endif
_nif71:

; 0717	call setyesno( flag% )
	push	word ptr ds:[w_20@FLAG]
	call	__setyesno

; 0719	case "EVAL"
	jmp	_clst1_end
_clst1_27:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_104
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_27
	jmp	_clst1_28
_cont1_27:

; 0720	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0721	call parse( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__parse

; 0722	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0724	case "CONTENTS"
	jmp	_clst1_end
_clst1_28:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_105
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_28
	jmp	_clst1_29
_cont1_28:

; 0725	call getvar( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__getvar

; 0726	print varvalue$
	mov	di,word ptr ds:[s_VARVALUE]
	call	_tty_str_dos

; 0727	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0729	case "VDEFINED"
	jmp	_clst1_end
_clst1_29:
	mov	di,word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_106
	call	_str_cs_ds
	push	si
	call	_str_compare
	pop	bx
	call	_mem_free
	test	ax,ax
	jnz	_cont1_29
	jmp	_clst1_30
_cont1_29:

; 0730	call substitute( rest$ )
	push	word ptr ds:[s_20@REST]
	call	__substitute

; 0731	call getvaroffset( subst$ )
	push	word ptr ds:[s_SUBST]
	call	__getvaroffset

; 0732	if varoffset% = 0 then
	cmp	word ptr ds:[w_VAROFFSET],0
	jz	short LL82
	jmp	_nif72
LL82:

; 0733	call setyesno( false )
	xor	ax,ax
	push	ax
	call	__setyesno

; 0734	else
	jmp	_eif72
_nif72:

; 0735	call setyesno( true )
	mov	ax,-1
	push	ax
	call	__setyesno

; 0736	endif
_eif72:

; 0737	failure% = false
	xor	ax,ax
	mov	word ptr ds:[w_FAILURE],ax

; 0739	case else
	jmp	_clst1_end
_clst1_30:

; 0740	failure% = true
	mov	word ptr ds:[w_FAILURE],-1

; 0741	temp$ = kwd$ + " unknown"
	mov	bx,word ptr ds:[s_20@TEMP]
	call	_mem_free
	push	word ptr ds:[s_20@KWD]
	mov	si,offset s_$SC_107
	call	_str_cs_ds_mark
	push	si
	mov	cx,2
	call	_str_mix
	mov	word ptr ds:[s_20@TEMP],di
	call	_str_release

; 0742	call defvar( "$ERROR", temp$ )
	mov	si,offset s_$SC_3
	call	_str_cs_ds_mark
	push	si
	push	word ptr ds:[s_20@TEMP]
	call	__defvar
	call	_str_release

; 0744	end select
_clst1_end:

; 0745	endprocess:
__endprocess:

; 0746	end sub
__process_end:
	mov	si,offset mr@cleanup_process
	call	_sub_cleanup
	ret	4
	mr@cleanup_process: dw s_20@REST,s_20@KWD,s_20@CERR,s_20@CRES,s_20@TEMP,s_20@CERRMSG,s_20@COMPAR,s_20@LH,s_20@RH,0
__process endp


_exit:
	call	mr@cleanup
_exit2:
	mov	ah,4ch
	int	21h

db 13,10,'Generated by MoonRock compiler v0.50; Portions (C) 1994-1998 by Rowan Crowe',13,10

public __ffblk_2disk
__ffblk_2disk:
	mov	si,offset bu_FFBLK + 09h
	mov	cx,13
	call	_mem2disk_null
	ret

public __ffblk_2mem
__ffblk_2mem:
	mov	si,offset bu_FFBLK + 09h
	mov	cx,13
	call	_disk2mem_null
	ret

public __ffblk_release
__ffblk_release:
	push	bx
	mov	bx,word ptr ds:[bu_FFBLK + 09h]
	call	_mem_free
	pop	bx
	ret


; Standard routines


public _finput
_finput:
mr@fbuf equ 09D1h
mr@fpos equ 09EFh
mr@finputeof equ 0A0Dh
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	bp
	mov	bp,bx
	mov	di,bx
	shl	di,1
	mov	si,word ptr ds:[mr@fbuf+di]
	or	si,si
	jz	I8
I1:
	cmp	word ptr ds:[mr@finputeof+di],-1
	jnz	I2
	xor	di,di
	jmp	I6
I2:
	add	si,word ptr ds:[mr@fpos+di]
	mov	cx,1024
	sub	cx,word ptr ds:[mr@fpos+di]
	jcxz	I9
	mov	di,si
	mov	bx,cx
	mov	al,13
	repnz	scasb
	jnz	I9
	sub	bx,cx
	mov	cx,bx
	add	bx,2
	call	_mem_alloc
	push	di
	add	di,2
	xor	dx,dx
	push	cx
I3:
	jcxz	I5
	lodsb
	cmp	al,9
	jz	I4
	cmp	al,32
	jb	I7
I4:
	inc	dx
	stosb
	loop	I3
I5:
	pop	cx
	pop	di
	mov	[di],dx
	mov	bx,bp
	shl	bx,1
	add	word ptr ds:[mr@fpos+bx],cx
I6:
	pop	bp
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
I7:
	loop	I3
	jmp	short I5
I8:
	push	di
	mov	bx,1024
	call	_mem_alloc
	mov	si,di
	pop	di
	mov	word ptr ds:[mr@fpos+di],1024
	mov	word ptr ds:[mr@fbuf+di],si
I9:
	mov	bx,bp
	shl	bx,1
	cmp	word ptr ds:[mr@finputeof+bx],-1
	jz	I13
	push	di
	mov	di,word ptr ds:[mr@fbuf+bx]
	push	di
	mov	si,di
	add	si,word ptr ds:[mr@fpos+bx]
	mov	cx,1024
	sub	cx,word ptr ds:[mr@fpos+bx]
	mov	dx,word ptr ds:[mr@fbuf+bx]
	add	dx,cx
	shr	cx,1
	rep	movsw
	adc	cx,cx
	rep	movsb
	mov	ah,3fh
	mov	cx,word ptr ds:[mr@fpos+bx]
	mov	si,cx
	mov	word ptr ds:[mr@fpos+bx],0
	mov	bx,bp
	int	21h
	or	ax,ax
	jz	I11
	cmp	ax,si
	jb	I12
I10:
	pop	si
	pop	di
	mov	di,bp
	shl	di,1
	jmp	I1
I11:
	mov	si,bp
	shl	si,1
	mov	word ptr ds:[mr@finputeof+si],-1
	mov	bx,word ptr ds:[mr@fbuf+si]
	call	_mem_free
	mov	word ptr ds:[mr@fbuf+si],0
	jmp	short I10
I12:
	mov	di,dx
	add	di,ax
	mov	cx,si
	sub	cx,ax
	dec	cx
	mov	al,13
	stosb
	xor	al,al
	shr	cx,1
	rep	stosw
	adc	cx,cx
	rep	stosb
	jmp	short I10
I13:
	mov	ax,8
	jmp	_err_msg

public _mem_alloc
_mem_alloc:
	push	ax
	push	bx
	push	si
	test	bx,1
	jz	I27
	inc	bx
I27:
	mov	di,$StartOfDynamic
I28:
	cmp	byte ptr [di],'R'
	jnz	I32
	cmp	byte ptr [di+1],'F'
	jz	I30
I29:
	mov	di,[di+6]
	or	di,di
	jnz	I28
	mov	ax,5
	jmp	_err_msg
I30:
	cmp	[di+2],bx
	jb	I29
	mov	word ptr [di],'AR'
	mov	[di+2],bx
	lea	si,[di+bx+16]
	cmp	si,[di+6]
	ja	I31
	lea	si,[di+bx+8]
	mov	word ptr [si],'FR'
	mov	ax,[di+6]
	sub	ax,si
	sub	ax,8
	mov	[si+2],ax
	mov	[si+4],di
	mov	ax,[di+6]
	mov	[si+6],ax
	mov	bx,[di+6]
	mov	[bx+4],si
	mov	[di+6],si
I31:
	add	di,8
	pop	si
	pop	bx
	pop	ax
	ret
I32:
	mov	ax,1
	jmp	_err_msg

public _mem_free
_mem_free:
	or	bx,bx
	jz	I35
	push	ax
	push	bx
	push	si
	push	di
	sub	bx,8
	cmp	word ptr [bx],'AR'
	jnz	I36
	mov	word ptr [bx],'FR'
	mov	si,[bx+4]
	mov	di,[bx+6]
	or	si,si
	jz	I33
	cmp	word ptr [si],'FR'
	jnz	I33
	mov	ax,[bx+2]
	add	ax,8
	add	[si+2],ax
	mov	[si+6],di
	mov	[di+4],si
	mov	word ptr [bx],'fr'
	mov	bx,si
I33:
	or	di,di
	jz	I34
	cmp	word ptr [di],'FR'
	jnz	I34
	mov	ax,[di+2]
	add	ax,8
	add	[bx+2],ax
	mov	ax,[di+6]
	mov	[bx+6],ax
	mov	word ptr [di],'fr'
I34:
	pop	di
	pop	si
	pop	bx
	pop	ax
I35:
	ret
I36:
	mov	ax,2
	jmp	_err_msg

public _sub_cleanup
_sub_cleanup:
	xor	ax,ax
I37:
	mov	di,cs:[si]
	or	di,di
	jz	I39
	mov	bx,[di]
	mov	[di],ax
	or	bx,bx
	jz	I38
	call	_mem_free
I38:
	add	si,2
	jmp	short I37
I39:
	ret

public _str_release
_str_release:
mr@markptr equ 0A2Bh
mr@marklist equ 0A2Dh
	push	bx
	push	cx
	push	si
	mov	cx,word ptr ds:[mr@markptr]
	jcxz	I43
	shr	cx,1
	mov	si,offset mr@marklist
I40:
	mov	bx,ds:[si]
	or	bx,bx
	jz	I41
	call	_mem_free
	jcxz	I42
I41:
	add	si,2
	loop	I40
I42:
	mov	word ptr ds:[mr@markptr],cx
I43:
	pop	si
	pop	cx
	pop	bx
	ret

public _exec
_exec:
execp_env equ 0A4Bh
execp_cmd equ 0A4Dh
execp_fc1 equ 0A51h
execp_fc2 equ 0A53h
	push	bx
	push	cx
	push	dx
	push	bp
	push	si
	push	di
	mov	bp,di
	clc
	xor	al,al
	call	_str_2_asciiz
	push	di
	mov	dx,di
	mov	si,bp
	mov	cx,ds:[si]
	mov	bx,cx
	add	bx,4
	call	_mem_alloc
	push	di
	lodsw
	mov	al,cl
	add	al,2
	stosb
	mov	al,' '
	stosb
	rep	movsb
	mov	word ptr ds:[di],13
	pop	di
	push	di
	mov	word ptr ds:[execp_cmd],di
	mov	word ptr ds:[execp_cmd+2],ds
	xor	ax,ax
	mov	word ptr ds:[execp_env],ax
	mov	word ptr ds:[execp_fc1],ax
	mov	word ptr ds:[execp_fc2],ax
	mov	ax,4b00h
	mov	bx,offset execp_env
	int	21h
	pop	bx
	pop	cx
	pushf
	call	_mem_free
	mov	bx,cx
	call	_mem_free
	popf
	jc	I70
	mov	ah,4dh
	int	21h
I69:
	pop	di
	pop	si
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	ret
I70:
	jmp	_err_dos

public _mem2disk_null
_mem2disk_null:
	ret

public _disk2mem_null
_disk2mem_null:
	push	bx
	push	di
	mov	di,si
	mov	al,0
	mov	bx,cx
	repnz	scasb
	jnz	I85
	sub	bx,cx
	lea	cx,[bx-1]
	jcxz	I86
I83:
	add	bx,2
	call	_mem_alloc
	mov	[di],cx
	push	di
	push	si
	add	di,2
	rep	movsb
	pop	si
	pop	word ptr [si]
I84:
	pop	di
	pop	bx
	ret
I85:
	mov	cx,bx
	jmp	I83
I86:
	mov	word ptr [si],cx
	jmp	short I84

public _str_cs_ds_mark
_str_cs_ds_mark:
	call	_str_cs_ds
	jmp	_str_mark_si

public _str_mark_si
_str_mark_si:
	push	bx
	mov	bx,word ptr ds:[mr@markptr]
	mov	word ptr ds:[mr@marklist+bx],si
	add	word ptr ds:[mr@markptr],2
	pop	bx
	ret

public _str_mark_di
_str_mark_di:
	push	bx
	mov	bx,word ptr ds:[mr@markptr]
	mov	word ptr ds:[mr@marklist+bx],di
	add	word ptr ds:[mr@markptr],2
	pop	bx
	ret

public _str_rtrim
_str_rtrim:
	push	ax
	push	bx
	push	cx
	push	si
	mov	cx,[si]
	jcxz	I107
	lodsw
	push	si
	add	si,cx
	inc	cx
I104:
	dec	si
	jcxz	I106
	dec	cx
	mov	al,[si]
	cmp	al,' '
	jbe	I104
	pop	si
	jcxz	I107
	mov	bx,cx
	add	bx,2
	call	_mem_alloc
	push	di
	mov	ax,cx
	stosw
	rep	movsb
	pop	di
I105:
	pop	si
	pop	cx
	pop	bx
	pop	ax
	ret
I106:
	pop	si
I107:
	xor	di,di
	jmp	short I105

public _sinstr
_sinstr:
mr@sinstr_set equ 0A55h
	push	bx
	push	cx
	push	dx
	push	bp
	mov	bx,di
	mov	di,offset mr@sinstr_set
	mov	dx,di
	xor	ax,ax
	mov	cx,128
	rep	stosw
	mov	cx,[bx]
	jcxz	I110
	add	bx,2
I108:
	mov	di,dx
	mov	al,[bx]
	add	di,ax
	mov	byte ptr [di],-1
	inc	bx
	loop	I108
	mov	cx,[si]
	jcxz	I110
	add	si,2
	xor	bp,bp
	mov	di,dx
	mov	bh,0
I109:
	inc	bp
	mov	bl,[si]
	inc	si
	cmp	byte ptr [di+bx],-1
	jz	I111
	loop	I109
I110:
	xor	ax,ax
	jmp	short I112
I111:
	xchg	ax,bp
I112:
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	ret

public _str_mix
_str_mix:
mr@str_mix_ret equ 0B55h
	pop	word ptr ds:[mr@str_mix_ret]
	push	bp
	mov	bp,sp
	add	bp,2
	push	ax
	push	bx
	push	dx
	push	si
	mov	dx,cx
	xor	si,si
	xor	ax,ax
I113:
	mov	bx,[bp+si]
	add	ax,[bx]
	add	si,2
	loop	I113
	mov	bx,ax
	push	bx
	add	bx,2
	call	_mem_alloc
	pop	ax
	push	di
	stosw
	mov	si,dx
	shl	si,1
I114:
	mov	bx,[bp+si-2]
	push	si
	mov	si,bx
	mov	cx,[si]
	lodsw
	shr	cx,1
	rep	movsw
	adc	cx,cx
	rep	movsb
	pop	si
	sub	si,2
	jnz	I114
	pop	di
	mov	cx,dx
	shl	cx,1
	pop	si
	pop	dx
	pop	bx
	pop	ax
	pop	bp
	add	sp,cx
	jmp	word ptr ds:[mr@str_mix_ret]

public _str_copy
_str_copy:
	push	ax
	push	bx
	push	cx
	mov	cx,[si]
	jcxz	I118
	add	cx,2
	mov	bx,cx
	call	_mem_alloc
	push	di
	shr	cx,1
	rep	movsw
	adc	cx,cx
	rep	movsb
	pop	di
I117:
	pop	cx
	pop	bx
	pop	ax
	ret
I118:
	xor	di,di
	jmp	short I117

public _str_cs_ds
_str_cs_ds:
	push	ax
	push	bx
	push	cx
	push	di
	push	ds
	push	es
	mov	ax,seg _STRCONST
	mov	es,ax
	mov	cx,es:[si]
	jcxz	I120
	add	cx,2
	mov	bx,cx
	call	_mem_alloc
	push	di
	push	ds
	pop	es
	mov	ax,seg _STRCONST
	mov	ds,ax
	shr	cx,1
	rep	movsw
	adc	cx,cx
	rep	movsb
	pop	si
I119:
	pop	es
	pop	ds
	pop	di
	pop	cx
	pop	bx
	pop	ax
	ret
I120:
	xor	si,si
	jmp	short I119

public _str_compare
_str_compare:
	push	cx
	push	si
	push	di
	xor	ax,ax
	mov	cx,[si]
	jcxz	I123
	cmp	cx,[di]
	jnz	I122
	add	si,2
	add	di,2
	rep	cmpsb
	jnz	I122
I121:
	dec	ax
I122:
	cmp	ax,-1
	pop	di
	pop	si
	pop	cx
	ret
I123:
	cmp	word ptr ds:[di],0
	jnz	I122
	jmp	I121

public _str_ucase
_str_ucase:
	push	ax
	push	bx
	push	cx
	mov	cx,[si]
	jcxz	I127
	mov	bx,cx
	add	bx,2
	call	_mem_alloc
	push	di
	mov	ax,cx
	stosw
	lodsw
I124:
	lodsb
	cmp	al,'a'
	jb	I125
	cmp	al,'z'
	ja	I125
	and	al,0dfh
I125:
	stosb
	loop	I124
	pop	di
I126:
	pop	cx
	pop	bx
	pop	ax
	ret
I127:
	xor	di,di
	jmp	short I126

public _str_left
_str_left:
	push	ax
	push	bx
	push	cx
	jcxz	I134
	cmp	cx,[si]
	jb	I132
	mov	cx,[si]
I132:
	mov	bx,cx
	add	bx,2
	call	_mem_alloc
	push	di
	lodsw
	mov	ax,cx
	stosw
	shr	cx,1
	rep	movsw
	adc	cx,cx
	rep	movsb
	pop	di
I133:
	pop	cx
	pop	bx
	pop	ax
	ret
I134:
	xor	di,di
	jmp	short I133

public _str_ltrim
_str_ltrim:
	push	ax
	push	bx
	push	cx
	mov	cx,[si]
	jcxz	I139
	lodsw
I138:
	mov	al,[si]
	cmp	al,' '
	ja	I140
	inc	si
	loop	I138
I139:
	xor	di,di
	jmp	short I141
I140:
	mov	bx,cx
	add	bx,2
	call	_mem_alloc
	push	di
	mov	ax,cx
	stosw
	rep	movsb
	pop	di
I141:
	pop	cx
	pop	bx
	pop	ax
	ret

public _cinstr
_cinstr:
	push	bx
	push	cx
	push	di
	xchg	cx,ax
	mov	cx,[si]
	jcxz	I142
	add	si,2
	mov	di,si
	repnz	scasb
	jz	I143
I142:
	xor	ax,ax
	jmp	short I144
I143:
	mov	ax,di
	sub	ax,si
I144:
	pop	di
	pop	cx
	pop	bx
	ret

public _str_mid
_str_mid:
	push	dx
	mov	dx,[si]
	sub	dx,bx
	jc	I147
	dec	bx
	cmp	cx,dx
	ja	I145
	or	cx,cx
	jnz	I146
I145:
	mov	cx,dx
	inc	cx
I146:
	add	si,bx
	mov	bx,cx
	add	bx,2
	call	_mem_alloc
	push	di
	lodsw
	mov	ax,cx
	stosw
	shr	cx,1
	rep	movsw
	adc	cx,cx
	rep	movsb
	pop	di
	pop	dx
	ret
I147:
	xor	di,di
	pop	dx
	ret

public _str_space
_str_space:
	or	cx,cx
	js	I148
	jcxz	I148
	push	ax
	push	bx
	mov	bx,cx
	add	bx,2
	call	_mem_alloc
	push	di
	mov	ax,cx
	stosw
	mov	al,' '
	rep	stosb
	pop	di
	pop	bx
	pop	ax
	ret
I148:
	xor	di,di
	ret

public _tty_str_dos
_tty_str_dos:
	push	ax
	push	bx
	push	cx
	push	dx
	mov	cx,[di]
	jcxz	I153
	lea	dx,[di+2]
	mov	ah,40h
	mov	bx,1
	int	21h
I153:
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

public _file_eof
_file_eof:
	push	bx
	push	cx
	push	dx
	push	bp
	push	si
	mov	si,bx
	add	si,si
	mov	bp,bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,4201h
	int	21h
	mov	bx,dx
	xchg	bx,bp
	mov	cx,ax
	call	_file_length
	sub	ax,cx
	sbb	dx,bp
	js	I170
	or	ax,ax
	jz	I170
I168:
	xor	ax,ax
I169:
	pop	si
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	ret
I170:
	cmp	word ptr ds:[mr@fbuf+si],0
	jz	I171
	mov	bx,word ptr ds:[mr@fbuf+si]
	cmp	word ptr [bx],0
	jnz	I168
I171:
	mov	ax,-1
	jmp	short I169

public _file_truename
_file_truename:
	push	ax
	push	bx
	push	cx
	mov	bx,128
	call	_mem_alloc
	push	di
	lodsw
	xchg	cx,ax
	rep	movsb
	mov	byte ptr [di],0
	pop	di
	push	di
	mov	si,di
	mov	ah,60h
	int	21h
	jc	I173
	pop	di
	mov	bx,di
	mov	dx,di
	call	_asciiz_2_str
	call	_mem_free
I172:
	pop	cx
	pop	bx
	pop	ax
	ret
I173:
	pop	bx
	call	_mem_free
	xor	di,di
	jmp	short I172

public _asciiz_2_str
_asciiz_2_str:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	mov	si,dx
	xor	cx,cx
I174:
	lodsb
	or	al,al
	jz	I175
	inc	cx
	jmp	short I174
I175:
	mov	bx,cx
	add	bx,2
	call	_mem_alloc
	push	di
	mov	ax,cx
	stosw
	mov	si,dx
	rep	movsb
I176:
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

public _str_2_asciiz
_str_2_asciiz:
	push	bx
	push	cx
	push	dx
	push	si
	push	bp
	jc	I177
	xor	dx,dx
	jmp	short I178
I177:
	mov	dx,1
I178:
	mov	bp,ax
	mov	bx,[si]
	mov	cx,bx
	add	bx,2
	call	_mem_alloc
	push	di
	lodsw
	or	dx,dx
	jz	I179
	mov	byte ptr [di],' '
	inc	di
I179:
	jcxz	I180
	rep	movsb
I180:
	mov	ax,bp
	stosb
	pop	di
	pop	bp
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret

public _file_create
_file_create:
mr@filename equ 0B57h
	push	bx
	push	cx
	push	dx
	push	di
	clc
	mov	al,0
	call	_str_2_asciiz
	push	di
	mov	dx,di
	mov	ah,3ch
	int	21h
	jc	I182
	call	_str_copy
	mov	bx,ax
	shl	bx,1
	mov	word ptr ds:[mr@filename+bx],di
I181:
	pop	bx
	call	_mem_free
	pop	di
	pop	dx
	pop	cx
	pop	bx
	ret
I182:
	jmp	_err_dos

public _file_open
_file_open:
	push	bx
	push	cx
	push	dx
	push	di
	push	bp
	mov	bp,cx
	clc
	mov	al,0
	call	_str_2_asciiz
	push	di
I183:
	mov	dx,di
	mov	ax,bp
	and	al,7fh
	mov	ah,3dh
	xor	cx,cx
	int	21h
	jc	I185
	call	_str_copy
	mov	bx,ax
	shl	bx,1
	mov	word ptr ds:[mr@filename+bx],di
	push	word ptr ds:[mr@fbuf+bx]
	mov	word ptr ds:[mr@fbuf+bx],0
	pop	bx
	call	_mem_free
	pop	bx
	call	_mem_free
I184:
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	bx
	ret
I185:
	cmp	ax,2
	jnz	I186
	test	bp,00000011b
	jz	I186
	mov	cx,20h
	push	si
	call	_file_create
	pop	si
	mov	bx,ax
	mov	ah,3eh
	int	21h
	jmp	I183
I186:
	jmp	_err_dos

public _file_close
_file_close:
	or	bx,bx
	jz	I189
	push	ax
	push	si
	mov	ah,3eh
	int	21h
	jc	I188
	add	bx,bx
	mov	si,bx
	mov	bx,word ptr ds:[mr@filename+si]
	call	_mem_free
	mov	bx,word ptr ds:[mr@fbuf+si]
	call	_mem_free
	xor	ax,ax
	mov	word ptr ds:[mr@filename+si],ax
	mov	word ptr ds:[mr@fpos+si],ax
	mov	word ptr ds:[mr@finputeof+si],ax
	mov	word ptr ds:[mr@fbuf+si],ax
I187:
	pop	si
	pop	ax
	ret
I188:
	jmp	_err_dos
I189:
	mov	ax,4
	jmp	_err_msg

public _file_length
_file_length:
	push	bp
	mov	bp,sp
	sub	sp,4
	push	cx
	xor	cx,cx
	xor	dx,dx
	mov	ax,4201h
	int	21h
	jc	I197
	mov	word ptr [bp-2],ax
	mov	word ptr [bp-4],dx
	xor	cx,cx
	xor	dx,dx
	mov	ax,4202h
	int	21h
	jc	I197
	push	ax
	push	dx
	mov	cx,word ptr [bp-4]
	mov	dx,word ptr [bp-2]
	mov	ax,4200h
	int	21h
	jc	I197
I196:
	pop	dx
	pop	ax
	pop	cx
	mov	sp,bp
	pop	bp
	ret
I197:
	jmp	_err_dos

public _file_print
_file_print:
	push	ax
	push	cx
	push	dx
	push	di
	mov	cx,[di]
	jcxz	I201
	lea	dx,[di+2]
	mov	ah,40h
	int	21h
	jc	I202
I201:
	pop	di
	pop	dx
	pop	cx
	pop	ax
	ret
I202:
	jmp	_err_dos

public _echo_strconst
_echo_strconst:
	xchg	si,di
	call	_str_cs_ds
	xchg	di,si
	push	di
	call	_tty_str_dos
	pop	bx
	call	_mem_free
	ret

public _echo_words
_echo_words:
	push	bx
	call	_words
	push	di
	call	_tty_str_dos
	pop	bx
	call	_mem_free
	pop	bx
	ret

public _file_exist
_file_exist:
	push	di
	call	_find_first
	or	di,di
	jz	I267
I266:
	call	_find_next
	or	di,di
	jnz	I266
	mov	ax,-1
	pop	di
	ret
I267:
	xor	ax,ax
	pop	di
	ret

public _find_first
_find_first:
mr@DTA equ 0B75h
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	xor	al,al
	clc
	call	_str_2_asciiz
	push	di
	mov	ah,1ah
	mov	dx,offset mr@DTA
	int	21h
	mov	ah,4eh
	pop	dx
	push	dx
	int	21h
	jc	I268
	pop	bx
	call	_mem_free
	mov	dx,offset mr@DTA + 1Eh
	call	_asciiz_2_str
	push	di
	mov	si,offset mr@DTA + 15h
	mov	di,offset b_FFBLK_ATTR
	mov	cx,4
	rep	movsw
	movsb
	pop	di
	jmp	short I269
I268:
	pop	bx
	call	_mem_free
	xor	di,di
	mov	ds:[s_FFBLK_NAME],di
I269:
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

public _find_next
_find_next:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	mov	ah,4fh
	int	21h
	jc	I270
	mov	dx,offset mr@DTA + 1Eh
	call	_asciiz_2_str
	push	di
	mov	si,offset mr@DTA + 15h
	mov	di,offset b_FFBLK_ATTR
	mov	cx,4
	rep	movsw
	movsb
	pop	di
	jmp	short I271
I270:
	xor	di,di
	mov	ds:[s_FFBLK_NAME],di
I271:
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

public _words
_words:
	push	ax
	push	bx
	push	cx
	push	dx
	mov	bx,7
	call	_mem_alloc
	push	di
	add	di,2
	xor	cx,cx
	cmp	ax,0
	jge	I272
	mov	byte ptr [di],'-'
	inc	di
	inc	cx
	neg	ax
I272:
	call	_word2
	pop	di
	mov	[di],cx
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

public _word2
_word2:
	mov	bx,10
	xor	dx,dx
	div	bx
	or	ax,ax
	jz	I273
	push	dx
	call	_word2
	pop	dx
I273:
	mov	al,dl
	or	al,'0'
	mov	[di],al
	inc	di
	inc	cx
	ret

public _inkey
_inkey:
	push	dx
	mov	ah,06h
	mov	dl,0ffh
	int	21h
	jz	I277
	mov	ah,0
	pop	dx
	ret
I277:
	mov	ax,-1
	pop	dx
	ret

public _keyboard_input
_keyboard_input:
	push	ax
	push	bx
	push	cx
	push	dx
	mov	dx,bx
	add	bx,2
	call	_mem_alloc
	push	di
	add	di,2
	xor	bx,bx
	cmp	cl,' '
	jz	I280
	push	cx
	mov	al,cl
	mov	cx,dx
I278:
	call	_tty
	loop	I278
	mov	al,8
	mov	cx,dx
I279:
	call	_tty
	loop	I279
	pop	cx
I280:
	mov	ah,07h
	int	21h
	cmp	al,' '
	jae	I282
	cmp	al,13
	jz	I283
	cmp	al,8
	jz	I281
	jmp	short I280
I281:
	or	bx,bx
	jz	I280
	dec	bx
	dec	di
	mov	al,8
	call	_tty
	mov	al,cl
	call	_tty
	mov	al,8
	call	_tty
	jmp	short I280
I282:
	cmp	bx,dx
	jz	I280
	mov	[di],al
	inc	bx
	inc	di
	call	_tty
	jmp	short I280
I283:
	pop	di
	push	di
	mov	[di],bx
	mov	si,di
	call	_str_copy
	pop	bx
	call	_mem_free
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

public _cmdline
_cmdline:
	push	ax
	push	bx
	push	cx
	push	ds
	push	es
	mov	es,word ptr ds:[mr@psp]
	mov	bl,es:[080h]
	or	bl,bl
	jz	I297
	xor	bh,bh
	add	bx,2
	call	_mem_alloc
	push	di
	push	ds
	pop	es
	mov	ds,word ptr ds:[mr@psp]
	mov	cl,ds:[080h]
	xor	ch,ch
	mov	es:[di],cx
	add	di,2
	mov	si,81h
	rep	movsb
	pop	di
I296:
	pop	es
	pop	ds
	pop	cx
	pop	bx
	pop	ax
	ret
I297:
	xor	di,di
	jmp	short I296

public _getenviron
_getenviron:
	push	ax
	push	bx
	push	bp
	push	si
	push	es
	call	_str_ucase
	mov	bp,di
	mov	es,word ptr ds:[mr@psp]
	mov	bx,es:[2ch]
	mov	es,bx
	xor	di,di
I301:
	mov	si,bp
	lodsw
	xchg	cx,ax
I302:
	mov	al,es:[di]
	inc	di
	cmp	al,'a'
	jb	I303
	cmp	al,'z'
	ja	I303
	and	al,0DFh
I303:
	cmp	al,ds:[si]
	jnz	I304
	inc	si
	loop	I302
	cmp	byte ptr es:[di],'='
	jnz	I304
	inc	di
	push	di
	mov	cx,7fffh
	xor	al,al
	repnz	scasb
	mov	bx,8001h
	sub	bx,cx
	call	_mem_alloc
	lea	cx,[bx-2]
	mov	[di],cx
	pop	si
	push	di
	add	di,2
	push	ds
	push	es
	push	ds
	pop	es
	pop	ds
	rep	movsb
	pop	ds
	pop	di
	jmp	I306
I304:
	xor	al,al
	mov	cx,7fffh
	repnz	scasb
	scasb
	jz	I305
	dec	di
	jmp	short I301
I305:
	xor	di,di
I306:
	pop	es
	pop	si
	pop	bp
	pop	bx
	pop	ax
	ret

public _err_msg
_err_msg:
	call	_cprint
	db	13,10,13,10
	db	'R'
	db	'untime error #',0
	call	_err_wordu
	call	_cprint
	db	13,10,0
	mov	ds,word ptr ss:[mr@ds]
	jmp	_exit
mr@err_table:

public _err_wordu
_err_wordu:
	mov	bx,10
	xor	dx,dx
	div	bx
	or	ax,ax
	jz	I322
	push	dx
	call	_err_wordu
	pop	dx
I322:
	or	dl,'0'
	mov	ah,02h
	int	21h
	ret

public _err_dos
_err_dos:
	cmp	ax,13
	jb	I323
	mov	ah,59h
	xor	bx,bx
	int	21h
I323:
	add	ax,100
	jmp	_err_msg

public _str_instr
_str_instr:
	push	bp
	mov	bp,sp
	sub	sp,16
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	mov	[bp-2],di
	mov	[bp-4],si
	cmp	word ptr [di],0
	jnz	I324
	mov	word ptr [bp-6],0
	jmp	I335
I324:
	cmp	word ptr [si],0
	jnz	I325
	mov	word ptr [bp-6],1
	jmp	I335
I325:
	mov	bx,[bp-2]
	mov	ax,ds:[bx]
	mov	[bp-8],ax
	mov	bx,[bp-4]
	mov	ax,ds:[bx]
	mov	[bp-10],ax
	mov	word ptr [bp-12],0
	mov	di,[bp-4]
	add	di,2
	mov	dl,byte ptr ds:[di]
	mov	word ptr [bp-12],0
I326:
	mov	si,[bp-2]
	add	si,[bp-12]
	lodsw
	xor	cx,cx
	mov	ax,[bp-12]
	mov	[bp-16],ax
I327:
	cmp	dl,byte ptr ds:[si]
	jnz	short I328
	mov	cx,-1
	mov	ax,word ptr [bp-16]
	mov	word ptr [bp-12],ax
	jmp	I329
I328:
	inc	si
	mov	ax,[bp-16]
	inc	ax
	cmp	ax,[bp-8]
	jg	I329
	mov	[bp-16],ax
	jmp	short I327
I329:
	test	cx,cx
	jnz	short I330
	mov	word ptr [bp-6],0
	jmp	I335
I330:
	mov	ax,[bp-16]
	inc	ax
	mov	[bp-6],ax
	mov	di,[bp-4]
	add	di,2
	mov	cx,-1
	mov	word ptr [bp-16],1
I331:
	mov	al,byte ptr ds:[si]
	cmp	al,byte ptr ds:[di]
	jz	short I332
	xor	cx,cx
	jmp	I333
I332:
	inc	si
	inc	di
	mov	ax,[bp-16]
	inc	ax
	cmp	ax,[bp-10]
	jg	I333
	mov	[bp-16],ax
	jmp	I331
I333:
	cmp	cx,-1
	jz	short I335
	mov	ax,[bp-12]
	inc	ax
	cmp	ax,[bp-8]
	jg	I334
	mov	[bp-12],ax
	jmp	I326
I334:
	mov	word ptr [bp-6],0
I335:
	mov	ax,[bp-6]
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	mov	sp,bp
	pop	bp
	ret

public _mypath
_mypath:
	push	ax
	push	bx
	push	cx
	push	si
	push	es
	mov	es,ds:[mr@psp]
	mov	bx,es:[2ch]
	mov	es,bx
	xor	al,al
	xor	di,di
	mov	cx,7fffh
I358:
	repnz	scasb
	scasb
	jnz	I358
	add	di,2
	push	di
	mov	cx,128
	repnz	scasb
	mov	bx,130
	sub	bx,cx
	call	_mem_alloc
	lea	cx,[bx-3]
	mov	[di],cx
	pop	si
	push	di
	add	di,2
	push	ds
	push	es
	push	ds
	pop	es
	pop	ds
	rep	movsb
	pop	ds
	pop	di
	pop	es
	pop	si
	pop	cx
	pop	bx
	pop	ax
	ret

public _ival
_ival:
	push	bx
	push	cx
	push	dx
	xor	cx,cx
	mov	bx,ds:[si]
	xor	ax,ax
	or	bx,bx
	jz	I363
	lodsw
I359:
	lodsb
	cmp	al,' '
	jbe	I359
	dec	si
	mov	ah,ch
	cmp	byte ptr ds:[si],'-'
	jnz	I360
	inc	si
	inc	bx
	mov	ah,1
I360:
	call	_mr$ivalS0
	jc	I362
	cmp	ah,0
	je	I361
	neg	cx
	clc
	jmp	short I362
I361:
	or	cx,cx
	clc
	jns	I362
	stc
I362:
	mov	ax,cx
I363:
	pop	dx
	pop	cx
	pop	bx
	ret

public _mr$ivalS0
_mr$ivalS0:
	pushf
	cld
I364:
	lodsb
	cmp	al,'0'
	jb	I365
	cmp	al,'9'
	ja	I365
	xor	al,'0'
	cmp	al,10
	ja	I365
	shl	cx,1
	jc	I366
	mov	dx,cx
	shl	cx,1
	jc	I366
	shl	cx,1
	jc	I366
	add	cx,dx
	jc	I366
	add	cl,al
	adc	ch,0
	jc	I366
	dec	bx
	jnz	I364
I365:
	popf
	clc
	ret
I366:
	popf
	stc
	ret

public _get_date
_get_date:
	push	ax
	push	bx
	push	cx
	push	dx
	mov	bx,13
	call	_mem_alloc
	push	di
	mov	ax,11
	stosw
	mov	ah,2ah
	int	21h
	mov	byte ptr ds:[b_DATEBLK_DAY],dl
	mov	byte ptr ds:[b_DATEBLK_MONTH],dh
	mov	word ptr ds:[w_DATEBLK_YEAR],cx
	mov	byte ptr ds:[b_DATEBLK_DOW],al
	mov	al,dl
	call	_dtS1
	mov	al,'-'
	stosb
	mov	al,dh
	dec	al
	mov	dh,3
	mul	dh
	mov	bx,ax
	xor	bh,bh
	add	bx,offset mr@monthlist
	mov	ax,cs:[bx]
	stosw
	mov	al,cs:[bx+2]
	stosb
	mov	al,'-'
	stosb
	sub	cx,1900
	cmp	cl,100
	mov	ch,13h
	jc	I391
	sbb	cl,100
	inc	ch
I391:
	mov	al,ch
	call	_dtS1
	mov	al,cl
	call	_dtS1
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
mr@monthlist:
	db	'JanFebMarAprMayJunJulAugSepOctNovDec'

public _dtS1
_dtS1:
	aam
	or	ax,3030h
	xchg	ah,al
	stosw
	ret

public _get_time
_get_time:
	push	ax
	push	bx
	push	cx
	push	dx
	mov	bx,10
	call	_mem_alloc
	push	di
	mov	word ptr [di],8
	add	di,2
	mov	ah,2ch
	int	21h
	mov	byte ptr ds:[b_TIMEBLK_HOUR],ch
	mov	byte ptr ds:[b_TIMEBLK_MINUTE],cl
	mov	byte ptr ds:[b_TIMEBLK_SECOND],dh
	mov	byte ptr ds:[b_TIMEBLK_SEC100],dl
	mov	al,ch
	call	_dtS1
	mov	al,':'
	stosb
	mov	al,cl
	call	_dtS1
	mov	al,':'
	stosb
	mov	al,dh
	call	_dtS1
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

public _cprint
_cprint:
	push	bp
	mov	bp,sp
	push	ax
	push	si
	mov	si,[bp+2]
I151:
	mov	al,cs:[si]
	or	al,al
	jz	I152
	call	_tty
	inc	si
	jmp	short I151
I152:
	inc	si
	mov	[bp+2],si
	pop	si
	pop	ax
	pop	bp
	ret

public _tty
_tty:
	push	ax
	push	dx
	mov	dl,al
	mov	ah,02h
	int	21h
	pop	dx
	pop	ax
	ret
_text ends
_data segment para public 'data'
assume cs:_data
_data ends
_text segment para public 'code'
assume cs:_text
mr@startup:
	mov	di,$StartOfDynamic
	mov	word ptr ds:[di],'FR'
	mov	word ptr ds:[di+2],$StrSegSize - 16 - $StartOfDynamic
	mov	word ptr ds:[di+4],ax
	mov	si,$StrSegSize - 8
	mov	word ptr ds:[di+6],si
	mov	word ptr ds:[si],'AR'
	mov	word ptr ds:[si+2],ax
	mov	word ptr ds:[si+4],di
	mov	word ptr ds:[si+6],ax
	jmp	__Main
mr@cleanup:
	ret
$StartOfDynamic equ 00BB5h
_text ends


_strconst segment para public 'data'
assume cs:_strconst
s_$SC_1: dw 7
db 'COMSPEC'
s_$SC_2: dw 8
db '$COMSPEC'
s_$SC_3: dw 6
db '$ERROR'
s_$SC_4: dw 5
db '$EXEC'
s_$SC_5: dw 6
db '$INPUT'
s_$SC_6: dw 5
db '$OPEN'
s_$SC_7: dw 5
db '$DONE'
s_$SC_8: dw 5
db 'FALSE'
s_$SC_9: dw 5
db '$DATE'
s_$SC_10: dw 5
db '$NULL'
s_$SC_11: dw 2
db '{}'
s_$SC_12: dw 2
db '%0'
s_$SC_13: dw 17
db 'no script file.',13,10
s_$SC_14: dw 4
db '.SLI'
s_$SC_15: dw 2
db '%1'
s_$SC_16: dw 1
db '%'
s_$SC_17: dw 15
db ' not found.',13,10,13,10
s_$SC_18: dw 6
db 'DEFINE'
s_$SC_19: dw 5
db '$LINE'
s_$SC_20: dw 24
db 'No instructions in file '
s_$SC_21: dw 2
db 13,10
s_$SC_22: dw 5
db '$TIME'
s_$SC_23: dw 14
db 'Error in line '
s_$SC_24: dw 4
db '--> '
s_$SC_25: dw 4
db ':',13,10,9
s_$SC_26: dw 4
db 'TRUE'
s_$SC_27: dw 20
db 'Substitue: theline$='
s_$SC_28: dw 3
db '{{}'
s_$SC_29: dw 3
db '{}}'
s_$SC_30: dw 1
db '{'
s_$SC_31: dw 1
db '}'
s_$SC_32: dw 14
db 'deepestToken$='
s_$SC_33: dw 9
db 'swapped$='
s_$SC_34: dw 10
db 'varvalue$='
s_$SC_35: dw 1
db 39
s_$SC_36: dw 1
db '/'
s_$SC_37: dw 1
db '-'
s_$SC_38: dw 9
db 'Variable '
s_$SC_39: dw 13
db ' not defined.'
s_$SC_40: dw 5
db 'LABEL'
s_$SC_41: dw 18
db 'Cannot find label '
s_$SC_42: dw 1
db 'Y'
s_$SC_43: dw 1
db 'N'
s_$SC_44: dw 1
db 7
s_$SC_45: dw 9
db 'process: '
s_$SC_46: dw 5
db 'DEBUG'
s_$SC_47: dw 2
db 'ON'
s_$SC_48: dw 3
db 'OFF'
s_$SC_49: dw 24
db 'DEBUG neither ON nor OFF'
s_$SC_50: dw 8
db 'MESSAGES'
s_$SC_51: dw 27
db 'MESSAGES neither ON nor OFF'
s_$SC_52: dw 11
db 'CONSIDERING'
s_$SC_53: dw 4
db 'CASE'
s_$SC_54: dw 8
db 'IGNORING'
s_$SC_55: dw 11
db 'TRANSLATION'
s_$SC_56: dw 7
db 'MESSAGE'
s_$SC_57: dw 2
db '\','n'
s_$SC_58: dw 4
db 'DUMP'
s_$SC_59: dw 1
db '='
s_$SC_60: dw 3
db 'SET'
s_$SC_61: dw 30
db 'Cannot SET undefined variable '
s_$SC_62: dw 1
db '.'
s_$SC_63: dw 3
db 'END'
s_$SC_64: dw 8
db 'MESSAGE '
s_$SC_65: dw 4
db 'BEEP'
s_$SC_66: dw 2
db 'DO'
s_$SC_67: dw 5
db 'INPUT'
s_$SC_68: dw 1
db ' '
s_$SC_69: dw 4
db 'GOTO'
s_$SC_70: dw 5
db 'IFYES'
s_$SC_71: dw 4
db 'IFNO'
s_$SC_72: dw 6
db 'EXISTS'
s_$SC_73: dw 5
db 'YESNO'
s_$SC_74: dw 4
db 'OPEN'
s_$SC_75: dw 7
db 'EXISTS '
s_$SC_76: dw 6
db 'CREATE'
s_$SC_77: dw 5
db 'WRITE'
s_$SC_78: dw 31
db 'Cannot write to an unopen file.'
s_$SC_79: dw 4
db 'READ'
s_$SC_80: dw 34
db 'Cannot read from an unopened file.'
s_$SC_81: dw 12
db 'End of file.'
s_$SC_82: dw 5
db 'CLOSE'
s_$SC_83: dw 37
db 'Cannot close a file that is not open.'
s_$SC_84: dw 6
db 'IFFAIL'
s_$SC_85: dw 4
db 'TEST'
s_$SC_86: dw 1
db '['
s_$SC_87: dw 1
db ']'
s_$SC_88: dw 10
db 'test: lh$='
s_$SC_89: dw 10
db 'test: rh$='
s_$SC_90: dw 3
db 'EQS'
s_$SC_91: dw 3
db 'LTS'
s_$SC_92: dw 3
db 'LES'
s_$SC_93: dw 3
db 'GES'
s_$SC_94: dw 3
db 'GTS'
s_$SC_95: dw 3
db 'NES'
s_$SC_96: dw 2
db 'EQ'
s_$SC_97: dw 2
db 'LT'
s_$SC_98: dw 2
db 'LE'
s_$SC_99: dw 2
db 'GE'
s_$SC_100: dw 2
db 'GT'
s_$SC_101: dw 2
db 'NE'
s_$SC_102: dw 3
db 'INC'
s_$SC_103: dw 10
db 'KEYPRESSED'
s_$SC_104: dw 4
db 'EVAL'
s_$SC_105: dw 8
db 'CONTENTS'
s_$SC_106: dw 8
db 'VDEFINED'
s_$SC_107: dw 8
db ' unknown'
_strconst ends
_stack segment para stack 'stack'
assume cs:_stack
mr@ds dw 1 dup (?)
db 2048 dup (?)
_stack ends
END	start_of_code
